# :hatching_chick: :frog: :chicken: 叽叽喳喳动物园模板_3

---

[TOC]

---

## STL

### algorithm

#### inplace_merge()

* 语法

```cpp
void inplace_merge(first, second, last, compfunction);
```

inplace_merge()函数原地合并数组
其中
first 表示第一段起始
second 表示第一段结束（不包含），第二段起始
last 表示第二段结束
com 是比较函数

* 使用模板

```cpp
// inplace_merge algorithm example
#include <iostream>
#include <algorithm>    // std::inplace_merge

int main () {
  int n = 5;
  int first[] = {3,10,1,2,5};
  int m = 2;
  inplace_merge(first, first+m, first+n);
  // first[] = {1,2,3,5,10};
  return 0;
}
```

#### merge()

* 语法

```cpp
void merge( list &lst );

void merge( list &lst, Comp compfunction );
```

merge()函数把自己和lst链表连接在一起，产生一个整齐排列的组合链表。如果指定compfunction，则将指定函数作为比较的依据。

* 使用模板

```cpp
// merge algorithm example
#include <iostream>     // std::cout
#include <algorithm>    // std::merge, std::sort
#include <vector>       // std::vector

int main () {
  int first[] = {5,10,15,20,25};
  int second[] = {50,40,30,20,10};
  std::vector<int> v(10);

  std::sort (first,first+5);
  std::sort (second,second+5);
  std::merge (first,first+5,second,second+5,v.begin());

  std::cout << "The resulting vector contains:";
  for (std::vector<int>::iterator it=v.begin(); it!=v.end(); ++it)
    std::cout << ' ' << *it;
  std::cout << '\n';

  return 0;
}

// Output:
// The resulting vector contains: 5 10 10 15 20 20 25 30 40 50
```

#### next_permutation()

* 语法

```cpp
bool next_permutation (BidirectionalIterator first,BidirectionalIterator last);

bool next_permutation (BidirectionalIterator first,BidirectionalIterator last, Compare comp);
```

next_permutation() 会生成一个序列的重排列，它是所有可能的字典序中的下一个排列，默认使用 < 运算符来做这些事情。它的参数为定义序的迭代器和一个返回布尔值的函数，这个函数在下一个排列大于上一个排列时返回 true，如果上一个排列是序列中最大的，它返回 false，所以会生成字典序最小的排列。

* 使用模板

```cpp
int main(){
    int len = 5;
    int b[] = {1,2,3,4,5};
    for(int i=0;i<120;i++){// 120 = 5 * 4 * 3 * 2 * 1
        for(int j=0;j<len;j++){
            cout<<b[j];
        }
        cout<<endl;
        next_permutation(b,b + len);
    }
    return 0;
}
```

#### sort()

* 语法

```cpp
void sort(Array.begin(), Array.end());
void sort(Array.begin(), Array.end(), cmp);
```

sort()函数为链表排序，默认是升序。如果指定compfunction的话，就采用指定函数来判定两个元素的大小。

* 使用模板

```cpp
typedef struct myNode{
    int score;
    int time;
} node;

bool cmp(node o1, node o2){
    if(o1.score == o2.score){
        return o1.time > o2.time;// 如果o1.score等于o2.score 那么按time从大到小排列
    }else{
        return o1.score > o2.score;// 二者不相等 按score从大到小排列
    }
}

node a[max_size];

sort(a, a + n, cmp);
```

### queue

#### priority_queue()

* 语法

```cpp
priority_queue<Type, Container, Functional>
//升序队列
priority_queue <int, vector<int>, greater<int> > q;
//降序队列
priority_queue <int, vector<int>, less<int> > q;
```

排序算法稳定性： **不稳定**

Type 就是数据类型， Container 就是容器类型（ Container 必须是用数组实现的容器，比如 vector , deque 等等，但不能用 list 。STL 里面默认用的是 vector ）， Functional 就是比较的方式，当需要用自定义的数据类型时才需要传入这三个参数，使用基本数据类型时，只需要传入数据类型，默认是大顶堆，由大到小出队。

* 使用模板

```cpp
// pair 比较，第一元素相同，比较第二元素
priority_queue<pair<int, int> > a;

// 自定义类型
// 方法1
struct tmp1 // 运算符重载 <
{
    int x;
    tmp1(int a) {x = a;}
    bool operator<(const tmp1& a) const
    {
        return x < a.x; // 大顶堆
    }
};

// 方法2
struct tmp2 // 重写仿函数
{
    bool operator() (tmp1 a, tmp1 b)
    {
        return a.x < b.x; // 大顶堆
    }
};
```

---

## 算法 & 数据结构

### 最大上升子列

#### :frog: 最大上升子列 模板

```cpp
#include <iostream>
#include <algorithm>

using namespace std;

int upp[109] = {0};
int num[109] = {0};
// 若求最大下降子序列 需将max()处判断条件反转（<>）并且将num[0]置为最大值
int main(){
    int n;
    cin>>n;
    // ------最大上升子列 O(n^2)------- //
    for(int i = 1; i <= n; i++) cin>>num[i];
    for(int i = 1; i <= n; i++){// 当前处理处于i处的最大值
        for(int j = 0; j < i; j++){// 注意这里用到index = 0, 当从后面往前求最大上升子列时要用到n+1 注意避免RE
            if(num[j] < num[i]) upp[i] = max(upp[i], upp[j] + 1);
        }
    }
    int res = *max_element(upp + 1, upp + n + 1);
    cout<<res<<endl;
    // -------------------------------- //
    return 0;
}
```

#### :earth_asia: 最大上升子列 模板

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;

int n;
int num[200005];
int upp[200005];

int main(){
    //O(nlogn)
    cin>>n;
    for(int i = 1; i <= n; ++i) cin>>num[i];
    int ans = 1; upp[1] = num[1];
    for(int i = 2; i <= n; ++i){
        int l = 1, r = ans, mid;
        while(l <= r){
            mid =(l + r)>>1;
            if(num[i] <= upp[mid])r = mid - 1;
            else l = mid + 1;
        }upp[l] = num[i];
        if(l > ans) ++ans;
    }cout<<ans<<endl;
    return 0;
}
```

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
using namespace std;

int n;
int num[200005];

//O(nlogn)
int cal(int *b){
    vector<int> s;
    for(int i = 0; i < n ;i++){
        if(s.empty()) s.push_back(b[i]);
        else{
            vector<int>::iterator it = upper_bound(s.begin(), s.end(), b[i]);
            if(it == s.end()) s.push_back(b[i]);
            else *it = b[i];
        }
    }
    return s.size();
}

int main(){
    cin>>n;
    for(int i = 1; i <= n; ++i) cin>>num[i];
    cout<<cal(num);
    return 0;
}
```

### 二分搜索

#### :frog: 二分搜索 模板

```cpp
sort(arrA + 1, arrA + 1 + n);// 首先保证有序
int left = 1, right = arrA[n];// 答案可能的范围
while(left <= right){
    int mid = (left + right) / 2;
    if(check(mid)/*检查函数看当前mid是否符合条件*/){// 符合的话区间还可以向右
        left = mid + 1;
    }else{// 不符合向左
        right = mid - 1;
    }
}
```

### 最大公约数

#### :frog: 辗转相除法 模板

```cpp
int gcd(int x,int y){
    if(!y) return x;
    return gcd(y, x % y);
}
```

### 快速幂

#### :frog: 快速幂 模板

```cpp
typedef long long ll;

ll qPow(ll x, ll y){
    ll res = 1;
    while(y){
        if(y & 1) res *= x;
        x *= x;
        y >>= 1;
    }
    return res;
}
```

### 逆序对

#### :frog: 求逆序对数 模板

```cpp
#include<iostream>
#include<cstdio>

using namespace std;

int n, arrA[500009] = {0}, arrB[500009] = {0};
long long sum = 0;

void solve(int left, int right){
    if(left >= right) return;
    int mid = (left + right) / 2;
    solve(left, mid), solve(mid + 1, right);
    int i = left, j = mid + 1, index = left;
    while(i <= mid && j <= right){
        if(arrA[i] > arrA[j]){// 逆序
            arrB[index++] = arrA[j++];
            sum += mid - i + 1;// i处元素大于j处元素 则i后面的元素也大于j处元素
        }else arrB[index++] = arrA[i++];
    }
    while(i <= mid) arrB[index++] = arrA[i++];
    while(j <= right) arrB[index++] = arrA[j++];
    for(int k = left; k <= right; k++) arrA[k] = arrB[k];
}

int main(){
// freopen("input.txt", "r", stdin);
    cin>>n;
    for(int i = 1; i <= n; i++){
        scanf("%d", &arrA[i]);
    }
    solve(1, n);
    cout<<sum<<endl;
    return 0;
}
```

### 背包

#### :hatching_chick: 01背包二维数组 模板

```cpp
#include<iostream>
#include<algorithm>
#include<cstring>

using  namespace std;

int m, n;  // m: 物品总数 n: 背包重量
int dp[1010][1010];

struct node{
    int w;
    int v;
}nn[1010];
//结构用来存放物品重量和价值

void nodee(){
    int  i , j;
    memset(dp,0,sizeof(dp));
    for(i = 1; i <= m; i++) {
        for(j = 0; j <= n; j++) {
            if(nn[i].w > j) {
                dp[i][j] = dp[i - 1][j];  // 判断该物品与当前储存背包大小，如果大于，则不取。
            }else {
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][ j - nn[i].w] + nn[i].v);  // 反之判断价值大小，取大的。
            }
        }
    }
}

int main()
{
    cin>>m>>n;
    for(int i = 1; i <= m; i++) {
        cin>>nn[i].v;
    }
    for(int  i = 1; i<= m; i++) {
        cin>>nn[i].w;
    }
    nodee();
    cout<<dp[m][n]<<endl;
    return 0;
}
```

#### :frog: 01背包二维数组 模板

```cpp
#include<iostream>
#include<cstring>

using namespace std;

int _size[3500] = {0};// 占用体积
int _value[3500] = {0};// 价值
int dp[1009][1009] = {0};// 结果集

/*
    01背包二维数组
*/

int main(){
    int n, maxSize;// 物体数量和背包容量
    cin>>n>>maxSize;
    for(int i = 1; i <= n; i++){
        cin>>_size[i]>>_value[i];
    }
    for(int i = 1; i <= n; i++){
            for(int j = 0; j <= maxSize; j++){
            if(_size[i] <= j){
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - _size[i]] + _value[i]);
            }else{
                dp[i][j] = dp[i - 1][j];
            }
        }
    }
    cout<<dp[n][maxSize];
    return 0;
}
```

#### :hatching_chick: 01背包滚动数组 模板

```cpp
#include<iostream>
#include<algorithm>
#include<cstring>

using  namespace std;

int m, n;  // m: 物品总数 n: 背包重量
int dp[1010];

struct node{
    int w;
    int v;
}nn[1010];
//结构用来存放物品重量和价值

void nodee(){ // 滚动数组
    int i, j;
    memset(dp,0,sizeof(dp));
    for(i = 1; i <= m; i++) {
        for(j = n; j >= nn[i].w; j--) {
            dp[j] = max(dp[j], dp[j - nn[j].w] + nn[j].v);
        }
    }
}

int main()
{
    cin>>m>>n;
    for(int i = 1; i <= m; i++) {
        cin>>nn[i].v;
    }
    for(int  i = 1; i<= m; i++) {
        cin>>nn[i].w;
    }
    nodee();
    cout<<dp[n]<<endl;
    return 0;
}
```

#### :frog: 01背包滚动数组 模板

```cpp
#include<iostream>
#include<cstring>

using namespace std;

int _size[3500] = {0};// 占用体积
int _value[3500] = {0};// 价值
int dp[13000] = {0};// 结果集
/*
    01背包滚动数组
*/
int main(){
    int n, maxSize;// 物体数量和背包容量
    cin>>n>>maxSize;
    for(int i = 1; i <= n; i++){
        cin>>_size[i]>>_value[i];
    }
    for(int i = 1; i <= n; i++){
        for(int j = maxSize; j >= _size[i]; j--){
            dp[j] = max(dp[j], dp[j - _size[i]] + _value[i]);
        }
    }
    cout<<dp[maxSize];
    return 0;
}
```

#### :frog: 完全背包滚动数组 模板

```cpp
#include<iostream>
#include<cstring>

using namespace std;

int _size[13000] = {0};// 占用体积
int _value[13000] = {0};// 价值
int dp[13000] = {0};// 结果集

/*
    完全背包滚动数组
*/

int main(){
    int n, maxSize;// 物体数量和背包容量
    cin>>n>>maxSize;
    for(int i = 1; i <= n; i++){
        cin>>_size[i]>>_value[i];
    }
    for(int i = 1; i <= n; i++){
        for(int j = _size[i]; j <= maxSize; j++){
            dp[j] = max(dp[j], dp[j - _size[i]] + _value[i]);
        }
    }
    cout<<[maxSize];
    return 0;
}
```

### 二叉树

#### :frog: 前序中序求后序 模板

```cpp
#include<iostream>
#include<string>

using namespace std;

string pre, mid;
int n = -1;
/*
    beginIndex从0 , endIndex从长度减一
    注意n需要初始化-1
*/
void solve(int beginIndex, int endIndex){
    if(beginIndex > endIndex) return;
    n++;
    int i;
    for(i = beginIndex; i <= endIndex; i++){
        if(pre[n] == mid[i]) break;
    }
    solve(beginIndex, i - 1);
    solve(i + 1, endIndex);
    cout<<mid[i];
}

int main() {
    while(cin>>pre>>mid) {
        solve(0, pre.length() - 1);
        n = -1;
        cout<<endl;
    }
    return 0;
}
```

### 大数计算

#### :earth_asia: 大数加法 模板

```cpp
#include<iostream>
#include<string>
#include<algorithm>
using namespace std;
#define n 10
/*
    大数加法
    如果遇到加负数的情况需要使用减法模版
*/
string dezero(string a)//用来去掉正数前面的0，也就是说可以输入000001类似这样的数字
{
    long int i;
    for(i=0;i<a.length();i++)
    {
        if(a.at(i)>48) break;
    }
    if(i==a.length()) return "0";
    a.erase(0,i);
    return a;
}
string add(string a,string b)//自然数加法
{
    a=dezero(a);
    b=dezero(b);
    string c;
    string d="0";
    long int kmin,kmax,i;
    reverse(a.begin(),a.end());
    reverse(b.begin(),b.end());
    if(a.length()>b.length()) {kmin=b.length();kmax=a.length();c=a;}
    else {kmin=a.length();kmax=b.length();c=b;}
    c.insert(c.length(),d);
    for(i=0;i<kmin;i++)
    {
        if(a.at(i)>=48&&a.at(i)<=57) a.at(i)-=48;
        if(a.at(i)>=97&&a.at(i)<=122) a.at(i)-=87;
        if(b.at(i)>=48&&b.at(i)<=57) b.at(i)-=48;
        if(b.at(i)>=97&&b.at(i)<=122) b.at(i)-=87;
        c.at(i)=a.at(i)+b.at(i);
    }
    for(i=kmin;i<kmax+1;i++)
    {
        if(c.at(i)>=48&&c.at(i)<=57) c.at(i)-=48;
        if(c.at(i)>=97&&c.at(i)<=122) c.at(i)-=87;
    }
    for(i=0;i<kmax;i++)
    {
        if(c.at(i)>=n)
        {
            c.at(i+1)+=c.at(i)/n;
            c.at(i)=c.at(i)%n;
        }
    }
    if(c.at(kmax)==0)
    {
        c.erase(kmax,kmax+1);
    }
    for(i=0;i<c.length();i++)
    {
        if(c.at(i)>=10) c.at(i)+=87;
        if(c.at(i)<10) c.at(i)+=48;
    }
    reverse(c.begin(),c.end());
    return c;
}
int main()
{
    string a,b;
    while(cin>>a>>b)
    {
        cout<<add(a,b);
    }
    return 0;
}
```

#### :earth_asia: 大数减法 模板

```cpp
#include<iostream>
#include<string>
#include<algorithm>
using namespace std;
#define n 10
/*
    大数减法
    同样不支持负数加减
*/
string dezero(string a)//用来去掉正数前面的0，也就是说可以输入000001类似这样的数字
{
    long int i;
    for(i=0;i<a.length();i++)
    {
        if(a.at(i)>48) break;
    }
    if(i==a.length()) return "0";
    a.erase(0,i);
    return a;
}
int judge(string a,string b)//判断两个正数的大小
{
    if(a.length()>b.length()) return 1;
    if(a.length()<b.length()) return -1;
    long int i;
    for(i=0;i<a.length();i++)
    {
        if(a.at(i)>b.at(i)) return 1;
        if(a.at(i)<b.at(i)) return -1;
    }
    return 0;
}
string sub(string a,string b)//自然数减法
{
    a=dezero(a);
    b=dezero(b);
    long int i,j=0;
    string c="0";
    string c1,c2;
    string d="-";
    if(judge(a,b)==0) return c;
    if(judge(a,b)==1)
    {
        c1=a;
        c2=b;
    }
    if(judge(a,b)==-1)
    {
        c1=b;
        c2=a;
        j=-1;
    }
    reverse(c1.begin(),c1.end());
    reverse(c2.begin(),c2.end());
    for(i=0;i<c2.length();i++)
    {
        if(c2.at(i)>=48&&c2.at(i)<=57) c2.at(i)-=48;
        if(c2.at(i)>=97&&c2.at(i)<=122) c2.at(i)-=87;
    }
    for(i=0;i<c1.length();i++)
    {
        if(c1.at(i)>=48&&c1.at(i)<=57) c1.at(i)-=48;
        if(c1.at(i)>=97&&c1.at(i)<=122) c1.at(i)-=87;
    }
    for(i=0;i<c2.length();i++)
    {
        c1.at(i)=c1.at(i)-c2.at(i);
    }
    for(i=0;i<c1.length()-1;i++)
    {
        if(c1.at(i)<0)
        {
            c1.at(i)+=n;
            c1.at(i+1)--;
        }
    }
    for(i=c1.length()-1;i>=0;i--)
    {
        if(c1.at(i)>0) break;
    }
    c1.erase(i+1,c1.length());
    for(i=0;i<c1.length();i++)
    {
        if(c1.at(i)>=10) c1.at(i)+=87;
        if(c1.at(i)<10) c1.at(i)+=48;
    }
    reverse(c1.begin(),c1.end());
    if(j==-1) c1.insert(0,d);
    return c1;
}
int main()
{
    string a,b;
    while(cout<<"input:"&&cin>>a>>b)
    {
        cout<<"output:"<<sub(a,b)<<endl;
    }
    return 0;
}
```

#### :earth_asia: 大数乘法 模板

```cpp
#include<iostream>
#include<string>
#include<algorithm>
using namespace std;
#define n 10
/*
    大数乘法
    整数乘法，正整数，负整数，0均可，主要思想就是乘法的笔算方法
*/
string dezero(string a)//用来去掉正数前面的0，也就是说可以输入000001类似这样的数字
{
    long int i;
    for(i=0;i<a.length();i++)
    {
        if(a.at(i)>48) break;
    }
    if(i==a.length()) return "0";
    a.erase(0,i);
    return a;
}
string multiply(string a,string b)//整数
{
    long int i,j,k,yao=0,kai;
    string c1,c2;
    string c3=a+b;
    if(a.at(0)=='-')
    {
        a.erase(0,1);
        yao++;
    }
    if(b.at(0)=='-')
    {
        b.erase(0,1);
        yao++;
    }
    a=dezero(a);
    b=dezero(b);
    if(a.at(0)==48||b.at(0)==48) return "0";
    if(a.length()>b.length())
    {
        c1=a;
        c2=b;
    }
    else
    {
        c1=b;
        c2=a;
    }
    reverse(c1.begin(),c1.end());
    reverse(c2.begin(),c2.end());
    for(i=0;i<c2.length();i++)
    {
        if(c2.at(i)>=48&&c2.at(i)<=57) c2.at(i)-=48;
        if(c2.at(i)>=97&&c2.at(i)<=122) c2.at(i)-=87;
    }
    for(i=0;i<c1.length();i++)
    {
        if(c1.at(i)>=48&&c1.at(i)<=57) c1.at(i)-=48;
        if(c1.at(i)>=97&&c1.at(i)<=122) c1.at(i)-=87;
    }
    for(i=0;i<c3.length();i++) c3.at(i)=0;
    for(i=0;i<c2.length();i++)
    {
        for(j=0;j<c1.length();j++)
        {
            kai=c2.at(i)*c1.at(j);
            c3.at(i+j+1)+=kai/n;
            c3.at(i+j)+=kai%n;
            for(k=i+j;k<c3.length()-1;k++)
            {
                if(c3.at(k)>=n)
                {
                    c3.at(k+1)+=c3.at(k)/n;
                    c3.at(k)=c3.at(k)%n;
                }
                else
                {
                    break;
                }
            }
        }
    }
    for(i=c3.length()-1;i>=0;i--)
    {
        if(c3.at(i)>0) break;
    }
    c3.erase(i+1,c3.length());
    for(i=0;i<c3.length();i++)
    {
        if(c3.at(i)>=10) c3.at(i)+=87;
        if(c3.at(i)<10) c3.at(i)+=48;
    }
    reverse(c3.begin(),c3.end());
    if(yao==1) c3="-"+c3;
    return c3;
}
int main()
{
    string a,b;
    while(cout<<"input:"&&cin>>a>>b)
    {
        cout<<"output:"<<multiply(a,b)<<endl;
    }
    return 0;
}
```

#### :earth_asia: 大数除法 模板

```cpp
#include<iostream>
#include<string>
#include<algorithm>
using namespace std;
#define n 10
/*
    大数除法
    用到减法函数sub
    除以0输出error
*/
string dezero(string a)//用来去掉正数前面的0，也就是说可以输入000001类似这样的数字
{
    long int i;
    for(i=0;i<a.length();i++)
    {
        if(a.at(i)>48) break;
    }
    if(i==a.length()) return "0";
    a.erase(0,i);
    return a;
}
int judge(string a,string b)//判断两个正数的大小
{
    if(a.length()>b.length()) return 1;
    if(a.length()<b.length()) return -1;
    long int i;
    for(i=0;i<a.length();i++)
    {
        if(a.at(i)>b.at(i)) return 1;
        if(a.at(i)<b.at(i)) return -1;
    }
    return 0;
}
string sub(string a,string b)//自然数减法（在之前博客中写到过，这里直接挪过来调用了）
{
    a=dezero(a);
    b=dezero(b);
    long int i,j=0;
    string c="0";
    string c1,c2;
    string d="-";
    if(judge(a,b)==0) return c;
    if(judge(a,b)==1)
    {
        c1=a;
        c2=b;
    }
    if(judge(a,b)==-1)
    {
        c1=b;
        c2=a;
        j=-1;
    }
    reverse(c1.begin(),c1.end());
    reverse(c2.begin(),c2.end());
    for(i=0;i<c2.length();i++)
    {
        if(c2.at(i)>=48&&c2.at(i)<=57) c2.at(i)-=48;
        if(c2.at(i)>=97&&c2.at(i)<=122) c2.at(i)-=87;
    }
    for(i=0;i<c1.length();i++)
    {
        if(c1.at(i)>=48&&c1.at(i)<=57) c1.at(i)-=48;
        if(c1.at(i)>=97&&c1.at(i)<=122) c1.at(i)-=87;
    }
    for(i=0;i<c2.length();i++)
    {
        c1.at(i)=c1.at(i)-c2.at(i);
    }
    for(i=0;i<c1.length()-1;i++)
    {
        if(c1.at(i)<0)
        {
            c1.at(i)+=n;
            c1.at(i+1)--;
        }
    }
    for(i=c1.length()-1;i>=0;i--)
    {
        if(c1.at(i)>0) break;
    }
    c1.erase(i+1,c1.length());
    for(i=0;i<c1.length();i++)
    {
        if(c1.at(i)>=10) c1.at(i)+=87;
        if(c1.at(i)<10) c1.at(i)+=48;
    }
    reverse(c1.begin(),c1.end());
    if(j==-1) c1.insert(0,d);
    return c1;
}
string divide(string a,string b)//自然数除法
{
    if(b.length()==1&&b.at(0)==48) return "error";
    long int i,j;
    string c1,c2,d,e;
    if(judge(a,b)==0) return "1";
    if(judge(a,b)==-1)
    {
        return "0";
    }
    c1=dezero(a);
    c2=dezero(b);
    d="";
    e="";
    for(i=0;i<c1.length();i++)
    {
        j=0;
        d=d+c1.at(i);
        d=dezero(d);
        while(judge(d,b)>=0)
        {
            d=sub(d,b);//调用之前的减法函数sub，在本文中也加了进来
            d=dezero(d);
            j++;
        }
        e=e+"0";
        e.at(i)=j;
    }
    for(i=0;i<e.length();i++)
    {
        if(e.at(i)>=10) e.at(i)+=87;
        if(e.at(i)<10) e.at(i)+=48;
    }
    e=dezero(e);
    return e;
}
int main()
{
    string a,b;
    while(cout<<"input:"&&cin>>a>>b)
    {
        cout<<"output:"<<divide(a,b)<<endl;
    }
    return 0;
}
```

### 判断素数

#### :earth_asia: 判断素数 模板

```cpp
bool isPrime(int n) {
    if(n == 2 || n == 3) return true;
    if(n % 6 != 1 && n % 6 != 5) return false;
    // gcc提交 sqrt() 里可以直接放 n ，c++ 提交需转化类型即 (double)n, 编译失败注意
    for(int i = 5; i <= (int)sqrt(n); i += 6) {
        if (n % i == 0 || n % (i + 2) == 0) return false;
    }
    return true;
}
```

### KMP

#### :frog: KMP 模板

```CPP
int _next[10009];
string strA, strB;

void setNext() {
    _next[0] = 0;
    int i = 1, j = 0;
    while(i < strB.length()) {
        if(strB[i] == strB[j]) {
            _next[i++] = ++j;
        } else if(j != 0) {
            j = _next[j - 1];
        } else {
            _next[i++] = 0;
        }
    }
}

int kmp() {
    setNext();
    int i = 0, j = 0;
    while(i < strA.length() && j < strB.length()) {
        if(strA[i] == strB[j]) {
            i++, ++j;
        } else if(j != 0) {
            j = _next[j - 1];
        } else {
            i++;
        }
    }
    if(j == strB.length()) return i - j;// 返回初次匹配坐标
    else return -1;// 不匹配返回-1
}
```

### 并查集

#### :frog: 并查集 模板

```cpp
int arrA[55]= {0};

void init(int x){
    while(x != 0){
        arrA[x] = x;
        x--;
    }
}

int find(int x) {
    if(arrA[x] != x) return find(arrA[x]);
    else return x;
}

void un(int a, int b) {
    int pareA = find(a);
    int pareB = find(b);
    arrA[pareB] = pareA;
}
```

#### :chicken: 并查集 模板

```cpp
#include<vector>

int re; // 剩余总集合数量

// vectorA要初始化，re要赋初值

int getRoot(int x, vector<int> &vectorA) {
    if (x != vectorA[x]) {
        vectorA[x] = getRoot(vectorA[x], vectorA);
    }
    return vectorA[x];
}

void merge(int a, int b, vector<int> &vectorA) {
    int aa = getRoot(a, vectorA);
    int bb = getRoot(b, vectorA);
    if (aa != bb) {
        vectorA[bb] = aa;
        re--;
    }
}
```

#### :earth_asia: 并查集 模板

* 非递归实现路径压缩

```cpp
int pre[1010]; //存放第i个元素的父节点

int unionsearch(int root) //查找根结点
{
    int son, tmp;
    son = root;
    while(root != pre[root]) //寻找根结点
        root = pre[root];
    while(son != root) //路径压缩
    {
        tmp = pre[son];
        pre[son] = root;
        son = tmp;
    }
    return root;
}

void join(int root1, int root2) //判断是否连通，不连通就合并
{
    int x, y;
    x = unionsearch(root1);
    y = unionsearch(root2);
    if(x != y) //如果不连通，就把它们所在的连通分支合并
        pre[x] = y;
}
```

### DFS

#### :earth_asia: DFS 模板

```cpp
void dfs() {
    if (到达终点状态) {
        ...//根据题意添加
        return;
    }
    if (越界或者是不合法状态) {
        return;
    }
    if (特殊状态) {
        // 剪枝
        return;
    }
    for (扩展方式) {
        if (扩展方式所达到的状态合法) {
            修改操作;// 根据题意添加
            标记;
            dfs();
            还原标记;
            // 是否还原标记根据题意
            // 如果加上（还原标记）就是 回溯法
        }
    }
}
```

### BFS

#### :frog: BFS 模板

```cpp
void bfs(){
    queue<int> que;
    que.push(1);
    while(que.size()){
        if(到达终点状态){
            //...
            return;
        }
        if(不合法返回){
            return;
        }
        if(特殊状态){
            //时间重置、记录总数、剪枝等等
        }
        for(扩展){
            if(如果能够到达且状态合法){
                // 标记
                queue.push(1);
            }
        }
        que.pop();
    }
}
```

---

## 搜索技术

### BFS-2

#### 双向广搜

##### 双向广搜 模板

> 2020-3-11 :frog: 整理

```cpp
// 双向广搜
void TBFS(){
   if(/*起点等于终点*/){
          found=true;
          return;
   }
   bool found=false;
   memset(visited,0,sizeof(visited));  // 判重数组
   visited[s1.x][s1.y]=1;   // 初始状态标记为1
   visited[s2.x][s2.y]=2;   // 结束状态标记为2
   Q1.push(s1);  // 初始状态入正向队列
   Q2.push(s2);  // 结束状态入反向队列
   while(!Q1.empty() || !Q2.empty()){
        if(!Q1.empty())
           BFS_expand(Q1,true);  // 在正向队列中搜索
        if(found)  // 搜索结束
            return ;
        if(!Q2.empty())
             BFS_expand(Q2,false);  // 在反向队列中搜索
        if(found) // 搜索结束
            return ;
   }
}
void BFS_expand(queue<Status> &Q,bool flag){// 这里可以去掉queue的引用传递改为全局变量方便一点
    s=Q.front();  // 从队列中得到头结点s
    Q.pop()
    for(/*每个s 的子节点 t*/){
        t.state=Gethash(t.temp)  // 获取子节点的状态
        if(flag){// 在正向队列中判断
            if (visited[t.state]!=1){// 没在正向队列出现过
                if(visited[t.state]==2) {// 该状态在反向队列中出现过
                    /*各种操作*/
                    found=true；
                    return;
                }
                visited[t.state]=1;   // 标记为在在正向队列中
                Q.push(t);  // 入队
            }
        }else{// 在正向队列中判断
            if (visited[t.state]!=2){// 没在反向队列出现过
                if(visited[t.state]==1){// 该状态在正向向队列中出现过
                    /*各种操作*/
                    found=true；
                    return;
                }
                visited[t.state]=2;  // 标记为在反向队列中
                Q.push(t);  // 入队
            }
        }
    }
}
```

### DFS-2

#### IDAstar

##### IDAstar 模板

> 2020-3-15 :frog: 整理

```cpp
#include<iostream>
#include<cmath>

using namespace std;

const int BEGINX = 0, BEGINY = 0, ENDX = 5, ENDY = 5, MAXH = 5;// 限制最大深度

int manhattanDistance(int x1, int y1, int x2, int y2) {
    return (abs(x1 - x2) + abs(y1 - y2));
}

bool idastar(int x, int y, int l, int maxL){
    if(l > maxL) return false;
    if(/*终点*/){
        return true;
    }
    if((l + manhattanDistance(x, y, ENDX, ENDY)) >= MAXH) return false;// 这是核心剪枝
    /*
    DFS操作
    */
    return false;
}

int main(){
    int maxl = 1;
    while(!idastar(BEGINX, BEGINY, 0, maxl)){
        maxl++;
    }
    return 0;
}
```

## 基础算法思想

### 分治法

#### 最近点对-分治法

##### 最近点对 模板

> 2020-9-19 :chicken: 整理

```cpp
typedef pair<double, double> P;
const double INF = 0xfffffffffffffffe;

// 传入数组总长
int N;

// 比较器，为了使用 STL 合并数轴左右两端已经按照 y 坐标从小到大排序的点
bool compare_y(P a, P b) {
    return a.second < b.second;
}

// 传入的数组 a 已经按照每个元素的 first 元素排序
// n 为传入数组长度
double closest_pair(P *a, int n) {
    if (n <= 1) return INF;

    // 设置将点分为两部分的下标
    int m = n / 2;

    // 保存将点分为两部分的 x 轴的坐标
    double x = a[m].first;

    // 获取两部分中，最小的点对距离
    double d = min(closest_pair(a, m), closest_pair(a+m, n-m));

    // 将已经按照 y 坐标值排好序的两部分合并为一部分
    inplace_merge(a, a+m, a+n, compare_y);

    vector<P> b;
    for (int i = 0; i < n; i++) {
        // 如果这个点和 分隔轴 x 的水平距离大于等于当前最短距离 d ，就不需要判断它
        if (fabs(a[i].first-x) >= d) continue;

        // 将当前符合条件的点和所有符合条件的点（距分隔轴的水平距离小于当前最短距离 d）做对比
        for (int j = b.size() - 1; j >= 0; j--) {
            // 计算坐标差值
            double dx = a[i].first - a[j].first;
            // 点已经按照 y 坐标排序，所以这个差值一定不是负数
            double dy = a[i].second - a[j].second;
            // 如果当前两个点的 y 轴距离已经大于等于 d ，那么这个点之前的所有点（距离当前点的 y 轴距离只能大于等于 d），均不需要再判断
            if (dy >= d) break;
            d = min(d, sqrt(dx*dx + dy*dy));
        }
        // 将这个点加入到符合条件的点的数组中
        b.push_back(a[i]);
    }

    return d;
}
```

#### 归并排序

##### 归并排序 模板

> 2020-2-20 :hatching_chick: 整理

```cpp
#include<bits/stdc++.h>

using namespace std;
void mergearray(int a[], int l , int mid, int r, int temp[]){ //将两个有序数组合并排序

    int i = l, j = mid + 1;
    int m = mid,  n = r;
    int k = 0;
    while(i <= m && j <= n) {
        if(a[i] < a[j])
            temp[k++] = a[i++];
        else
            temp[k++] = a[j++];
    }
    //将剩余的元素存放到临时数组中
    while(i <= m)
        temp[k++] = a[i++];
    while( j <= n)
        temp[k++] = a[j++];
    for(int i = 0; i < k; i++) //临时存放数组的元素存放到原数组中
        a[l + i] = temp[i];

}

void mergesort(int a[], int l, int r, int temp[]){ //将任意两个数组合并排序
    if(l < r) {
        int mid = (l + r) / 2;
        mergesort(a,l,mid,temp); //左边有序
        mergesort(a,mid+1,r,temp); // 右边有序
        mergearray(a,l,mid,r,temp); //将两个有序的数组合并
    }
}

int main(){
    int a[1005];
    int temp[1005];
    int n;
    scanf("%d",&n);
    for(int i = 0; i < n; i++) {
        scanf("%d",&a[i]);
    }
    mergesort(a,0,n-1,temp);
    for(int i = 0 ;i < n; i++) {
        printf("%d ", a[i]);
    }
    return 0;
}
```

##### 归并排序求逆序对 模板

> 2020-2-20 :hatching_chick: 整理

```cpp
#include<iostream>

using namespace std;
const int MAXN = 100005;
typedef long long ll;
ll a[MAXN], b[MAXN], cnt;
void mergearray(ll l, ll mid, ll r){ //将两个有序数组合并排序
    ll i = l, j = mid + 1, t = 0;
    while(i <= mid && j <= r) {
        if(a[i] > a[j]) {
            b[t++] = a[j++];
            cnt += mid - i + 1; //记录逆序对数量
        }
        else
            b[t++] = a[i++];
    }
    //将剩余的元素存放到临时数组中
    while(i <= mid)
        b[t++] = a[i++];
    while(j <= r)
        b[t++] = a[j++];
    for(ll i = 0; i < t; i++) //临时存放数组的元素存放到原数组中
        a[l + i] = b[i];
}

void mergesort(ll l, ll r){ //将任意两个数组合并排序
    if(l < r) {
        ll mid = (l + r) / 2;
        mergesort(l,mid); //左边有序
        mergesort(mid+1,r); // 右边有序
        mergearray(l,mid,r); //将两个有序的数组合并
    }
}

int main(){
    ll n,k;
    while(~scanf("%lld %lld", &n, &k)){
        for(ll i = 0; i < n; i++) {
            scanf("%lld",&a[i]);
        }
        cnt = 0;
        mergesort(0,n-1);
        if(cnt <= k) printf("0\n");
        else printf("%I64d\n", cnt-k);
    }
    return 0;
}
```

#### 快速排序

##### 快速排序模板

> 2020-2-23 :hatching_chick: 整理

```cpp
#include<bits/stdc++.h>

using namespace std;

//数组打印
void print(int a[], int n){
    for(int i = 0; i < n; i++) {
        cout<<a[i]<<" ";
    }
    cout<<endl;
}

//找到每次的基数位置
int quickposition(int s[], int l, int r){
    int i = l, j = r, x = s[l]; // 以最左元素为基数
    while(i < j) {
        //从右向左找到第一个小于x的数
        while(i < j && s[j] >= x) {
            j--;
        }
        if(i < j) {
            s[i] = s[j]; // 直接替换掉最左元素 最左元素已经备份于x
            i++;
        }
        //从左向右找第一个大于x的数
        while(i < j && s[i] <= x) {
            i++;
        }
        if(i < j) {
            s[j] = s[i]; // 替换掉最右元素，最左元素已替换
            j--;
        }
    }
    s[i] = x; // i的位置放x，其左侧元素都小于x，右侧元素都大于x
    return i;
}

void quickSort(int s[], int l, int r){
    //数组左界小于右界才有意义，否则说明都已排好，直接返回即可。
    if(l >= r) {
        return;
    }

    //划分 找到基数位置
    int i = quickposition(s,l,r);

    //递归处理左右俩部分 i为分界点
    quickSort(s,l,i-1);
    quickSort(s,i+1,r);
}

int main(){
    int arr[] = {72,6,57,88,60,42,83,73,48,85};
    print(arr,10);
    quickSort(arr,0,9); //最后一个参数为n-1
    print(arr,10);
    return 0;
}
```

## 动态规划

### 基础 DP

#### 硬币问题

##### 不限定硬币数量求每个金额最小硬币数 模板

> 2020-3-12 :hatching_chick: 整理

```cpp
/*
    以下为不限定硬币数量 求每个金额的最小硬币数量
*/
const int MONEY = 251; //定义最大金额
const int value = 5; //5种硬币
int type[value] = {1, 5, 10, 25, 50};//5种面值
int Min[MONEY]; //每个金额对应最少的硬币数量
int Min_path[MONEY] = {0}; //记录最少硬币的路径
void solve(){
    for(int i = 0; i < MONEY; i++) { //初始值为无穷大
        Min[i] = INT_MAX;
    }
    Min[0] = 0;
    for(int i = 0; i < value; i++) {
        for(int j = type[i]; j < MONEY; j++) {
            if(Min[j] > Min[j - type[i]] + 1) {
                Min_path[j] = type[i]; // 在每个金额上记录路径，即某个硬币的面值
                Min[j] = Min[j - type[i]] + 1;
            }
            Min[j] = min(Min[j],Min[j - type[i]] + 1);
        }
    }
}

void print(int *Min_path, int s) { //打印硬币组合
    while(s){
        cout<<Min_path[s]<<" ";
        s = s - Min_path[s];
    }
}
```

##### 限定硬币数量求一种金额的所有组合方案 模板

> 2020-3-12 :hatching_chick: 整理

```cpp
/*
    以下为限定硬币数量 求该金额所对应的所有组合方案数
*/
const int COIN = 101; //要求不超过的硬币数量
const int MONEY = 251; //给定的钱数不超过的金额
int dp[MONEY][COIN] = {0};
int type[5] = {1, 5, 10, 25, 50};
void solve(){
    dp[0][0] = 1;
    for(int i = 0; i < 5; i++) {
        for(int j = 1;j < COIN; j++) {
            for(int k = type[i]; k < MONEY; k++) {
                dp[k][j] += dp[k - type[i]][j-1];
            }
        }
    }
}

int main(){
    int ans[MONEY] = {0}; //记录对应金额的方案
    solve();
    for(int i = 0; i < MONEY; i++) {
        for(int j = 0; j < COIN; j++) {
            ans[i] += dp[i][j];
        }
    }
}
```

#### 最长公共子序列

##### 最长公共子序列 O(mn) 模板

> 2020-2-20 :frog: 整理

```cpp
int dp[1009][1009] = {0};
string strA, strB;

// 最长公共序列 非子串
int lcs(){
    memset(dp, 0, sizeof(dp));
    for(int i = 1; i <= strA.length(); i++){// 注意从1开始
        for(int j = 1; j <= strB.length(); j++){
            if(strA[i - 1] == strB[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
            else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
        }
    }
    return dp[strA.length()][strB.length()];
}
```

##### 最长公共子序列 滚动 模板

> 2020-2-20 :frog: 整理

```cpp
// 最长公共序列 非子串 滚动
int lcs(){
    memset(dp, 0, sizeof(dp));
    bool nowR = 1, preR = 0;
    for(int i = 0; i < strA.length(); i++){
        int j = 0;
        for(swap(nowR, preR), j = 0; j < strB.length(); j++){
            if(strA[i] == strB[j]) dp[nowR][j + 1] = dp[preR][j] + 1;
            else dp[nowR][j + 1] = dp[preR][j + 1] > dp[nowR][j] ? dp[preR][j + 1] : dp[nowR][j];
        }
    }
    return dp[nowR][strB.length()];
}
```

### 递推与记忆化搜索

#### 递推

##### 数塔最大和问题递推 模板

> 2020-2-23 :chicken: 整理

```cpp
int a[150][150];// a[i][j]是数塔第 i 层的第 j 个数
int dp[150][150];//dp[i][j]记录从第 i 层第 j 个数开始向下可以得到的最大值
for (int j = 1; j <= n; j++) {
    dp[n][j] = a[n][j];
}
for (int i = n - 1; i > 0; i--) {
    for (int j = 1; j <= i; j++) {
        dp[i][j] = a[i][j] + max(dp[i+1][j], dp[i+1][j+1]);
    }
}
return dp[1][1];
```

#### 递归+记忆化搜索

##### 数塔最大和问题递归+记忆化搜索 模板

> 2020-2-23 :chicken: 整理

```cpp
int a[150][150];// a[i][j]是数塔第 i 层的第 j 个数
int dp[150][150];//dp[i][j]记录从第 i 层第 j 个数开始向下可以得到的最大值，初始化为 -1
int dfs(int i, int j) {
    if (i == n) return a[i][j];
    if (dp[i][j] >= 0) return dp[i][j];
    dp[i][j] = max(dfs(i+1, j), dfs(i+1, j+1)) + a[i][j];
    return dp[i][j];
}
```

### 区间 DP

#### 回文串

##### 得到回文串的最小花费 模板

> 2020-3-12 :chicken: 整理

```cpp
int m;// 给定字符串的长度
char s[m];// 字符串
int n;// 字符串中出现的小写字母个数
int w[26];// 每个小写字母对应的改变价值（给定的增加或删除价值中的较小者）
int dp[m][m];// 区间 i, j 变成回文的最小花费
for (int i = m - 1; i >= 0; i--) {
    // i 是子区间起点
    for (int j = i + 1; j > m; j++) {
        // j 是子区间终点
        // 如果区间两端相同，说明已经是回文串
        if (s[i] == s[j]) dp[i][j] = dp[i+1][j-1];
        // 否则改变其中一个位置，变成回文串
        else dp[i][j] = min(dp[i+1][j] + w[s[i]-'a'], dp[i][j-1] + w[s[j]-'a']);
    }
}
return dp[0][m-1];
```

## 数学

### 高精度计算

> 2020-3-21 :hatching_chick: 整理

#### 加法 模板

```cpp
#include <iostream>
#include <cstring>
using namespace std;

struct HugeInt{
    int len;
    int num[100001];
};

HugeInt a, b, w;        //w为结果
char c[100001], d[100001];

void Scan_HugeInt() {   //读入两个大整数
    cin >> c;
    cin >> d;
    a.len = strlen(c); //strlen求串长
    b.len = strlen(d);
    for(int i=0; i<a.len; i++) a.num[a.len - i] = c[i] - '0'; //逆序存储
    for(int i=0; i<b.len; i++) b.num[b.len - i] = d[i] - '0';
}

void Plus() {
    w.len = max(a.len, b.len);           //num每一位是0，长度取max不影响加法
    for(int i=1; i<=w.len; i++) {
        w.num[i] += a.num[i] + b.num[i];
        w.num[i+1] += w.num[i] / 10;    //处理进位
        w.num[i] %= 10;                 //处理当前位 保证<10
    }
    if(w.num[w.len + 1] != 0) w.len ++;  //加法最多有可能会多出一位
}

int main() {
    Scan_HugeInt();
    Plus();
    for(int i=w.len; i>=1; i--) cout << w.num[i]; //倒序存储 倒序输出
    cout << endl;
    return 0;
}
```

#### 减法 模板

```cpp
#include <iostream>
#include <cstring>
using namespace std;

struct HugeInt {
    int len;
    int num[100001];
};

HugeInt a, b, w;         //w为结果
char c[100001], d[100001];
bool negative;           //负数标记

void Scan_HugeInt() {    //读入两个大整数
    cin >> c;
    cin >> d;
    if((strlen(c) < strlen(d)) || (strlen(c) == strlen(d) && strcmp(c, d) < 0)) { //若被减数小 交换 记为负数
        negative = true;
        swap(c, d);
    }
    a.len = strlen(c);
    b.len = strlen(d);
    for(int i=0; i<a.len; i++) a.num[a.len - i] = c[i] - '0';
    for(int i=0; i<b.len; i++) b.num[b.len - i] = d[i] - '0';
}

void Minus() {
    w.len = a.len;                //a更大
    for(int i=1; i<=w.len; i++) {
        if(a.num[i] < b.num[i]) {
            a.num[i+1] --;      //num[i+1]减成负数也不影响
            a.num[i] += 10;     //借位
        }
        w.num[i] += a.num[i] - b.num[i];
    }
    while(w.num[w.len] == 0 && (w.len != 1)) w.len --; //多余的不是个位的0去掉
}

int main() {
    Scan_HugeInt();
    Minus();
    if(negative == true) cout << "-";             //负数加负号
    for(int i=w.len; i>=1; i--) cout << w.num[i]; //倒序存储 倒序输出
    cout << endl;
    return 0;
}
```

#### 乘法 模板

```cpp
#include <iostream>
#include <cstring>
using namespace std;

struct HugeInt {
    int len;
    int num[100001];
};

HugeInt a, b, w;
char c[10001], d[10001];

void Scan_HugeInt() {    //读入两个大整数
    cin >> c;
    cin >> d;
    a.len = strlen(c);
    b.len = strlen(d);
    for(int i=0; i<a.len; i++) a.num[a.len - i] = c[i] - '0';
    for(int i=0; i<b.len; i++) b.num[b.len - i] = d[i] - '0';
}

void Multiply() {
    int x;              //处理每次进位的变量
    for(int i=1; i<=a.len; i++) {      //a的第i位
        x = 0;
        for(int j=1; j<=b.len; j++) { //b的第j位
            w.num[i+j-1] += a.num[i] * b.num[j] + x; //用 +=:结果与上次乘的结果相加
            x = w.num[i+j-1] / 10;
            w.num[i+j-1] %= 10;          //进位处理
        }
        w.num[i+b.len] = x;  //多出的最高位
    }
    w.len = a.len + b.len;
    while(w.num[w.len] == 0 && (w.len != 1)) w.len --; //多余的0
}

int main() {
    Scan_HugeInt();
    Multiply();
    for(int i=w.len; i>=1; i--) cout << w.num[i];
    cout << endl;
    return 0;
}
```

### 数论

#### 快速幂-2

##### 矩阵快速幂 模板

> 2020-3-15 :frog: 整理

斐波那契数列的另一个公式是：

$\begin{bmatrix}F_{n+1} & F_n\\F_n & F_{n-1}\\\end{bmatrix} =\begin{bmatrix}1 & 1\\1 & 0\\\end{bmatrix}^n = \underbrace{\begin{bmatrix}1 & 1\\1 & 0\\\end{bmatrix} + \begin{bmatrix}1 & 1\\1 & 0\\\end{bmatrix} \cdots \begin{bmatrix}1 & 1\\1 & 0\\\end{bmatrix}}_\text{n times}$

```cpp
#include<iostream>
#include<string>
#include<cstring>
using namespace std;

const int MAXN = 2; //矩阵的阶
const int MOD = 10000;//题目要求模

struct Matrix{
    int m[MAXN][MAXN];
    Matrix(){
        memset(m, 0, sizeof(m));
    }
    Matrix operator *(Matrix a){// 矩阵乘法
        Matrix res;
        for(int i = 0; i < MAXN; i++){
            for(int j = 0; j < MAXN; j++){
                for(int k = 0; k < MAXN; k++){
                    res.m[i][j] = (res.m[i][j] + m[i][k] * a.m[k][j]) % MOD;
                }
            }
        }
        return res;
    }
};

int MPow(Matrix a, int n){// 矩阵快速幂
    Matrix res;
    for(int i = 0; i < MAXN; i++) res.m[i][i] = 1;
    while(n){
        if(n & 1) res = res * a;
        a = a * a;
        n >>= 1;
    }
    return res.m[0][1];
}

int main(){
    int n;
    while(cin>>n){
        if(n == -1) return 0;
        Matrix a;
        a.m[0][0] = 1;
        a.m[0][1] = 1;
        a.m[1][0] = 1;
        a.m[1][1] = 0;
        cout<<MPow(a, n)<<endl;
    }
    return 0;
}
```

#### 扩展欧几里得算法与二元一次方程的整数解

##### 扩展欧几里得算法求解二元一次方程 模板

> 2020-3-16 :hatching_chick: 整理

```cpp
#include<bits/stdc++.h>

using namespace std;
//满足ax + by = gcd(a,b) 可求得一个点(x0,y0);
int  extend_gcd(int a, int b, int &x, int &y){
    if(b == 0) {
        x = 1, y = 0;
        return a;
    }

    int d = extend_gcd(b,a%b,x,y);
    int tmp = x;
    x = y;
    y = tmp - (a / b) * y;
    return d; //得到a，b的最大公因数
}

int main(){
    int a, b, c;
    scanf("%d%d%d",&a,&b,&c); //ax + by = c  满足ax + by = gcd(a,b)
    int x, y, d;
    d = extend_gcd(a,b,x,y);  //得到a，b的最大公因数
    if(c % d != 0 ) printf("No solution!\n");
    else {
        a /= d, b /= d, c /= d;
        x *= c, y *= c;
        printf("特解: %d %d\n",x,y);
        printf("一个通解: %d %d\n",x+b,y-a);
    }
    return 0;
}
```

### 组合数学

#### 杨辉三角和二项式系数

##### 求杨辉三角的某项或某行 模板

> 2020-3-15 :chicken: 整理

```cpp
#include<vector>

typedef long long ll;

/**
 * 得到杨辉三角第 n 行，第 m 项，0 <= m <= n
 * 塔尖为第 0 行，第 0 项
 * re *= (n - prev + 1) 此处可能溢出，所以需确保 n <= 61
 * 利用二项式系数与杨辉三角中项的关系进行计算
 */
ll getGen(int n, int m) {
    if (m == 0 || m == n) return 1;
    ll re = 1;
    for (int prev = 1; prev <= m; prev++) {
        re *= (n - prev + 1);
        re /= prev;
    }
    return re;
}

/**
 * 得到杨辉三角第 n 行，结果放在 ans[] 中
 * 约定 ans 的长度为 n+1 ，塔尖为第 0 行
 * ans[prev] = ans[prev-1] * (n - prev + 1) 此处可能溢出，所以需确保 n <= 61
 * 利用二项式系数与杨辉三角中项的关系进行计算
 */
void getGens(int n, vector<ll> &ans) {
    ans[0] = 1;
    ans[n] = 1;
    for (int prev = 1; prev < n; prev++) {
        ans[prev] = ans[prev-1] * (n - prev + 1);
        ans[prev] /= prev;
    }
}
```

#### 母函数

##### 普通型母函数求整数划分 模板

> 2020-3-23 :chicken: 整理

```cpp
/**
 * 计算后， c1[n] 就是整数 n 的划分数
 */
const int MAXN = 200;
int c1[MAXN+1], c2[MAXN+1];
void part() {
    int i,j,k;
    for (i = 0; i <= MAXN; i++) {
        c1[i] = 1;
        c2[i] = 0;
    }
    for (k = 2; k <= MAXN; k++) {
        for (i = 0; i <= MAXN; i++) {
            for (j = 0; j + i <= MAXN; j += k) {
                c2[i+j] += c1[i];
            }
        }
        for (i = 0; i <= MAXN; i++) {
            c1[i] = c2[i];
            c2[i] = 0;
        }
    }
}
int main() {
    int n;
    part();
    while(cin>>n) cout<<c1[n]<<'\n';
    return 0;
}
```

##### 指数型母函数求排列组合数 模板

> 2020-3-24 :chicken: 整理

指数型母函数的定义：

对序列 $a_0, a_1, a_2, \cdots$

构造函数：

$G(x) = \frac{a_0}{0!}x^0 + \frac{a_1}{1!}x^1 + \frac{a_2}{2!}x^2 + \frac{a_3}{3!}x^3 \cdots$

称 $G(x)$ 为序列 $a_0, a_1, a_2, \cdots$ 的指数型母函数

```cpp
// n 物品种类， m 共选出几种物品， vectorA 每种物品对应的数量
// 过程是对指数型母函数公式的展开
// 过程结束后 c1 的第 i 项代表选 i 件物品时的排列数量 x 除以 i!
double c1[11];
double c2[11];

int main() {
    int n, m;
    vector<double> factorial(11);
    factorial[0] = 1;
    for (int i = 1; i <= 10; i++) {
        factorial[i] = factorial[i-1] * i;
    }

    while (cin>>n>>m) {
        vector<int> vectorA(n+1);
        for (int i = 1; i <= n; i++) {
            cin>>vectorA[i];
        }
        memset(c1, 0, sizeof(c1));
        memset(c2, 0, sizeof(c2));

        for (int i = 0; i <= vectorA[1]; i++) {
            c1[i] = 1.0 / factorial[i];
        }

        for (int i = 2; i <= n; i++) {
            for (int j = 0; j <= m; j++) {
                for (int z = 0; z <= vectorA[i] && j + z <= m; z++) {
                    c2[j+z] += c1[j] / factorial[z];
                }
            }

            for (int j = 0; j <= m; j++) {
                c1[j] = c2[j];
                c2[j] = 0;
            }
        }

        printf("%.lf\n", c1[m]*factorial[m]);
    }
    return 0;
}
```

#### 特殊计数

##### Catalan 数（卡特兰数） 模板 & 解题示例

> 2020-3-27 :chicken: 整理

Catalan 数定义：

$C_n = \frac{1}{n+1} \tbinom{2n}{n}, n = 0, 1, 2, \cdots$

三种计算方法：

* $C_n = C_0C_{n-1} + C_1C_{n-2} + \cdots + C_{n-2}C_1 + C_{n-1}C_0 = \sum_{k = 0}^{n-1}C_kC_{n-k-1}, C_0 = 1$

* $C_n = \frac{4n-2}{n+1} C_{n-1}, C_0 = 1$

* $C_n = \frac{1}{n+1} \tbinom{2n}{n} = \frac{(2n)!}{(n+1)!n!}$

对应问题：

* 棋盘问题
* 括号问题
* 出栈序列问题
* 二叉树问题

```cpp
// HDU 1023
#include<iostream>
#include<cstdio>
#include<cstring>

using namespace std;

// 大数位数
#define MAX 101

// 10000 进制
#define BASE 10000

// 进行大数 a 和 整数 b 的乘法运算，BASE 为基数
void multiply(int a[], int len, int b) {
    for(int i = len - 1, carry = 0; i >= 0; i--) {
        carry += b * a[i];
        a[i] = carry % BASE;
        carry /= BASE;
    }
}

// 进行大数 a 和 整数 b 的除法运算，BASE 为基数
void divide(int a[], int len, int b) {
    for(int i = 0, div = 0; i < len; i++) {
        div = div * BASE + a[i];
        a[i] = div / b;
        div %= b;
    }
}

// 公式二求卡特兰数列前 100 项
int main() {
    // 答案容器， 101 由可得到的最大项数 n 加一得出。求前 n 项，此处应填 n + 1
    int ans[101][MAX];
    memset(ans[1], 0, MAX*sizeof(int));
    // 初始化第一项为 1
    ans[1][MAX-1] = 1;
    // 由公式二计算
    for(int i = 2; i <= 100; i++) {
        memcpy(ans[i], ans[i-1], MAX*sizeof(int));
        multiply(ans[i], MAX, 4*i-2);
        divide(ans[i], MAX, i+1);
    }
    int n;
    while(cin>>n) {
        int j = 0;
        while (j < MAX && ans[n][j] == 0) j++;
        printf("%d", ans[n][j++]);
        while (j < MAX) {
            // 基数为 10000 ，所以需要在位数不足 4 时输出占位 0
            printf("%04d", ans[n][j++]);
        }
        cout<<'\n';
    }
    return 0;
}
```

### 公平组合游戏

#### 巴什游戏与 P-position, N-position

##### 巴什游戏 模板

> 2020-2-23 :frog: 整理

```cpp
/*
巴什游戏
n个石子 甲先取 乙后取 每次可以拿1-m个石子 轮流拿 拿到最后一个石子的人获胜
*/
void solve(){
    int n, m;
    cin>>n>>m;
    if(n % (m + 1) == 0) cout<<"second"<<endl;
    else cout<<"first"<<endl;
}
```

#### 尼姆游戏

##### 尼姆游戏 模板

> 2020-3-18 :frog: 整理

```cpp
#include<iostream>
#include<cmath>

using namespace std;
/*
    尼姆游戏
    地上有n堆石子（每堆石子数量小于10000），
    每人每次可从任意一堆石子里取出任意多枚石子扔掉，可以取完，不能不取。
    每次只能从一堆里取。最后没石子可取的人就输了。
    假如甲是先手，且告诉你这n堆石子的数量，他想知道是否存在先手必胜的策略。
    第一行一个整数n，表示有n堆石子。
    第二行有n个数，表示每一堆石子的数量
*/
int main(){
    int n = 0, temp=0, ret=0;
    cin>>n;
    for(int i = 1; i <= n; i++){
        cin>>temp;
        ret ^= temp;
    }
    if(ret) cout<<"Yes"<<endl;
    else cout<<"No"<<endl;
    return 0;
}
```

#### 威佐夫游戏

##### 威佐夫游戏 模板

> 2020-3-18 :frog: 整理

```cpp
#include<iostream>
#include<cmath>

using namespace std;
/*
    威佐夫游戏
    游戏规定，每次有两种不同的取法，一是可以在任意的一堆中取走任意多的石子；
    二是可以在两堆中同时取走相同数量的石子。最后把石子全部取完者为胜者。
    现在给出初始的两堆石子的数目，如果轮到你先取，假设双方都采取最好的策略，问最后你是胜者还是败者。
    1表示自己是胜者
*/
int main(){
    int n, m;
    double gold = (1 + sqrt(5)) / 2;
    while(cin>>n>>m){
        int a = min(n, m);
        int b = max(n, m);
        double k = (double)(b - a);
        int test = (int)(k * gold);
        if(test == a) cout<<0<<endl;
        else cout<<1<<endl;
    }
    return 0;
}
```

## 字符串

### 字符串哈希

#### 字符串哈希 模板 & 解题示例

> 2020-3-25 :hatching_chick: 整理

```cpp
/*输入若干个店家，和n天涨价的价格，输出n天后memory店的价格在所有店里面的排名
Sample Input
3
memory
kfc
wind
2
49 memory
49 kfc
48 wind
80 kfc
85 wind
83 memory

Sample Output
1
2

*/
#include<bits/stdc++.h>
using namespace std;

const int N = 10005;

struct node {
    char name[35];
    int price;
};

vector<node> List[N]; //用于解决冲突

unsigned int BKDRHash(char *str) { //哈希函数
    unsigned int seed = 31, key = 0;
    while(*str) {
        key = key * seed + (*str++);
    return key & 0x7fffffff;
    }
}

int main() {
    int n, m, key, add, memory_price, rank, len;
    int p[N];
    char s[35];
    node t;
    while(cin>>n) {
        for(int i = 0; i < N; i++) {
            List[i].clear();
        }
        for(int i = 0; i < n; i++) {
            cin>>t.name;
            key = BKDRHash(t.name) % N; //计算hash值 并求余
            List[key].push_back(t); //hash值可能冲突，把冲突的哈希值都存起来
        }
        cin>>m;
        while(m--){
            rank = len = 0;
            for(int i = 0; i < n; i++) {
                cin>>add>>s;
                key = BKDRHash(s) % N; //计算hash值
                for(int j = 0; j < List[key].size(); j++) { //处理冲突问题
                    if(strcmp(List[key][j].name,s) == 0) {
                        List[key][j].price += add;
                        if(strcmp(s,"memory") == 0) {
                            memory_price = List[key][j].price;
                        }else {
                            p[len++] = List[key][j].price;
                        }
                        break;
                    }
                }
            }
            for(int i = 0; i < len; i++) {
                if(memory_price < p[i]) {
                    rank++;
                }
            }
            cout<<rank+1<<endl;
        }
    }
    return 0;
}
```

### AC自动机

#### AC自动机 模板

>2020-3-24 :frog: 整理

```cpp
#include<iostream>
#include<queue>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define MAX_N 1000006
#define MAX_tot 500005

using namespace std;
/*
AC自动机
输入：
1
5
she
he
say
shr
her
yasherhs
输出：
3
*/

struct aho {
    struct state {
        int next[26];
        int fail, cnt;
    }statetable[MAX_tot];
    int size;
    std::queue<int>que;

    void init(){
        while (que.size()) que.pop();
        for (int i = 0;i < MAX_tot;i++){
            memset(statetable[i].next, 0, sizeof(statetable[i].next));
            statetable[i].fail = 0;
            statetable[i].cnt = 0;
        }
        size = 1;
    }
    void insert(char*S){
        int n = strlen(S);
        int now = 0;
        for (int i = 0;i < n;i++){
            char c = S[i];
            if (!statetable[now].next[c - 'a'])
                statetable[now].next[c - 'a'] = size++;
            now = statetable[now].next[c - 'a'];
        }
        statetable[now].cnt++;
    }


    void build(){
        statetable[0].fail = -1;
        que.push(0);

        while (que.size()){
            int u = que.front();
            que.pop();
            for (int i = 0;i < 26;i++){
                if (statetable[u].next[i]){
                    if (u == 0) statetable[statetable[u].next[i]].fail = 0;
                    else{
                        int v = statetable[u].fail;
                        while (v != -1){
                            if (statetable[v].next[i]){
                                statetable[statetable[u].next[i]].fail = statetable[v].next[i];
                                break;
                            }
                            v = statetable[v].fail;
                        }
                        if (v == -1) statetable[statetable[u].next[i]].fail = 0;
                    }
                    que.push(statetable[u].next[i]);
                }
            }
        }
    }

    int get(int u) {
        int res = 0;
        while (u){
            res += statetable[u].cnt;
            statetable[u].cnt = 0;
            u = statetable[u].fail;
        }
        return res;
    }
    int match(char*S){
        int n = strlen(S);
        int res = 0, now = 0;
        for (int i = 0;i < n;i++){
            char c = S[i];
            if (statetable[now].next[c - 'a']) now = statetable[now].next[c - 'a'];
            else {
                int p = statetable[now].fail;
                while (p != -1 && statetable[p].next[c - 'a'] == 0)
                    p = statetable[p].fail;
                if (p == -1)
                    now = 0;
                else
                    now = statetable[p].next[c - 'a'];
            }
            if (statetable[now].cnt)
                res = res + get(now);
        }
        return res;
    }
}aho;

int t;
int n;
char S[MAX_N];
int main(){
    scanf("%d", &t);
    while (t--){
        aho.init();
        scanf("%d", &n);
        for (int i = 0;i < n;i++){
            scanf("%s", S);
            aho.insert(S);
        }
        aho.build();
        scanf("%s", S);
        printf("%d\n", aho.match(S));
    }
    return 0;
}
```

## 计算几何

### 二维几何基础

#### 凸包

##### 凸包 模板 & 解题示例

> 2020-3-22 :frog: 整理

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
/*
    凸包
    给定一些点 求能够把这些点包含在内的面积最小的多边形。
测试用例
9
12 7
24 9
30 5
41 9
80 7
50 87
22 9
45 1
50 7
0
输出用例
243.06
*/
const int maxn = 104;
const double eps = 1e-8;

// 判断x是否等于0
int sgn(double x){
    if(fabs(x) < eps) return 0;
    else return x < 0 ? -1 : 1;
}
struct Point{
    double x, y;
    Point(){}
    Point(double x, double y) : x(x) , y(y){}
    Point operator + (Point B){
        return Point(x + B.x, y + B.y);
    }
    Point operator - (Point B){
        return Point(x - B.x, y - B.y);
    }
    bool operator == (Point B){
        return sgn(x - B.x) == 0 && sgn(y - B.y) == 0;
    }
    bool operator < (Point B){
        return sgn(x - B.x) < 0 || (sgn(x - B.x) == 0 && sgn(y - B.y) < 0);
    }
};

typedef Point Vector;

double Cross(Vector A, Vector B){
    return A.x * B.y - A.y * B.x;
}
double Distance(Point A, Point B){
    return hypot(A.x - B.x, A.y - B.y);
}

// 求凸包
int Convex_hull(Point *p, int n, Point *ch){
    sort(p, p + n);
    n = unique(p, p + n) - p;
    int v = 0;
    for(int i = 0; i < n; i++){
        while(v > 1 && sgn(Cross(ch[v - 1] - ch[v - 2], p[i] - ch[v - 2])) <= 0) v--;
        ch[v++] = p[i];
    }
    int j = v;
    // 求上凸包
    for(int i = n - 2; i >= 0; i--){
        while(v > j && sgn(Cross(ch[v - 1] - ch[v - 2], p[i] - ch[v - 2])) <= 0) v--;
        ch[v++] = p[i];
    }
    if(n > 1) v--;
    return v;
}

int main(){
    int n;
    Point p[maxn], ch[maxn];
    while(scanf("%d", &n) && n){
        for(int i = 0; i < n; i++) scanf("%lf %lf", &p[i].x, &p[i].y);
        int v = Convex_hull(p, n, ch);
        double ans = 0;
        if(v == 1) ans = 0;
        else if(v == 2) ans = Distance(ch[0], ch[1]);
        else{
            for(int i = 0; i < v; i++) ans += Distance(ch[i], ch[(i + 1) % v]);
        }
        printf("%.2lf\n", ans);
    }
}
```

#### 最近点对

##### 求最近点距离 模板

> 2020-3-18 :chicken: 整理

```cpp
/**
 * 计算最近点距离之前要先排序一次 sort(p, p+n, cmpxy)
 */
const double eps = 1e-8;
const int MAXN = 100010;
const double INF = 1e20;

int sgn(double x) {
    if(fabs(x) < eps) return 0;
    else return x < 0 ? -1 : 1;
}

struct Point{
    double x,y;
 };

double Distance(Point A, Point B) {
    return hypot(A.x-B.x,A.y-B.y);
}

// 先对横坐标 x 排序，再对 y 排序
bool cmpxy(Point A,Point B) {
    return sgn(A.x-B.x) < 0 || (sgn(A.x-B.x) == 0 && sgn(A.y-B.y) < 0);
}

// 只对 y 坐标排序
bool cmpy (Point A,Point B) {
    return sgn(A.y-B.y)<0;
}

Point p[MAXN],tmp_p[MAXN];

double Closest_Pair(int left, int right) {
    double dis = INF;
    // 只剩1个点
    if(left == right) return dis;
    // 只剩2个点
    if(left + 1 == right) {
        return Distance(p[left], p[right]);
    }
    // 分治
    int mid = (left + right) / 2;
    // 求s1内的最近点对
    double d1 = Closest_Pair(left, mid);
    // 求s2内的最近点对
    double d2 = Closest_Pair(mid+1, right);
    dis = min(d1, d2);
    int k = 0;

    // 在s1和s2中间附近找可能的最小点对
    for(int i = left; i <= right; i++){
        // 按x坐标来找
        if(fabs(p[mid].x - p[i].x) <= dis) {
            tmp_p[k++] = p[i];
        }
    }

    // 按y坐标排序，用于剪枝。这里不能按x坐标排序
    sort(tmp_p, tmp_p+k, cmpy);
    for(int i = 0; i < k; i++) {
        for(int j = i + 1; j < k; j++) {
            // 剪枝
            if(tmp_p[j].y - tmp_p[i].y >= dis) break;
            dis = min(dis, Distance(tmp_p[i], tmp_p[j]));
        }
    }
    // 返回最小距离
    return dis;
}
```

### 几何模板

> 2020-2-20 :chicken: 整理

#### 公共部分

```cpp
#include <bits/stdc++.h>
using namespace std;
const double pi = acos(-1.0);  //高精度圆周率
const double eps = 1e-8;       //偏差值
const int maxp = 1010;         //点的数量
int sgn(double x){  //判断x是否等于0
    if(fabs(x) < eps)  return 0;
    else return x<0?-1:1;
}
int Dcmp(double x, double y){  //比较两个浮点数：0 相等；-1 小于；1 大于
    if(fabs(x - y) < eps) return 0;
    else return x<y ?-1:1;
}
```

#### 平面几何：点和线 模板

```cpp
//---------------平面几何：点和线--------
struct Point{  //定义点和基本运算
    double x,y;
    Point(){}
    Point(double x,double y):x(x),y(y){}
    Point operator + (Point B){return Point(x+B.x,y+B.y);}
    Point operator - (Point B){return Point(x-B.x,y-B.y);}
    Point operator * (double k){return Point(x*k,y*k);}    //长度增大k倍
    Point operator / (double k){return Point(x/k,y/k);}    //长度缩小k倍
    bool operator == (Point B){return sgn(x-B.x)==0 && sgn(y-B.y)==0;}
    bool operator < (Point B){return sgn(x-B.x)<0 || (sgn(x-B.x)==0 && sgn(y-B.y)<0);} //用于凸包
};
typedef Point Vector;   //定义向量
double Dot(Vector A,Vector B){return A.x*B.x + A.y*B.y;} //点积
double Len(Vector A){return sqrt(Dot(A,A));}   //向量的长度
double Len2(Vector A){return Dot(A,A);}        //向量长度的平方
double Angle(Vector A,Vector B){return acos(Dot(A,B)/Len(A)/Len(B));}   //A与B的夹角
double Cross(Vector A,Vector B){return A.x*B.y - A.y*B.x;} //叉积
double Area2(Point A, Point B, Point C){return Cross(B-A, C-A);} //三角形ABC面积的2倍
double Distance(Point A, Point B){return hypot(A.x-B.x,A.y-B.y);}   //两点的距离
double Dist(Point A,Point B){return sqrt((A.x-B.x)*(A.x-B.x) + (A.y-B.y)*(A.y-B.y));}
Vector Normal(Vector A){return Vector(-A.y/ Len(A), A.x/ Len(A));}  //向量A的单位法向量

bool Parallel(Vector A, Vector B){return sgn(Cross(A,B)) == 0;}//向量平行或重合)

Vector Rotate(Vector A, double rad){  //向量A逆时针旋转rad度
    return Vector(A.x*cos(rad)-A.y*sin(rad), A.x*sin(rad)+A.y*cos(rad));
}

struct Line{
    Point p1,p2;//线上的两个点
    Line(){}
    Line(Point p1,Point p2):p1(p1),p2(p2){}
   // Line(Point x,Point y){p1 = x;p2 = y;}
  //  Point(double x,double y):x(x),y(y){}
//根据一个点和倾斜角 angle 确定直线,0<=angle<pi
    Line(Point p,double angle){
        p1 = p;
        if(sgn(angle - pi/2) == 0){p2 = (p1 + Point(0,1));}
        else{p2 = (p1 + Point(1,tan(angle)));}
    }
//ax+by+c=0
    Line(double a,double b,double c){
        if(sgn(a) == 0){
            p1 = Point(0,-c/b);
            p2 = Point(1,-c/b);
        }
        else if(sgn(b) == 0){
            p1 = Point(-c/a,0);
            p2 = Point(-c/a,1);
        }
        else{
            p1 = Point(0,-c/b);
            p2 = Point(1,(-c-a)/b);
        }
    }
};

typedef Line Segment;   //定义线段，两端点是Point p1,p2

//返回直线倾斜角 0<=angle<pi
double Line_angle(Line v){
    double k = atan2(v.p2.y-v.p1.y, v.p2.x-v.p1.x);
    if(sgn(k) < 0)k += pi;
    if(sgn(k-pi) == 0)k -= pi;
        return k;
}
//点和直线关系:1 在左侧;2 在右侧;0 在直线上
int Point_line_relation(Point p,Line v){
    int c = sgn(Cross(p-v.p1,v.p2-v.p1));
    if(c < 0)return 1;       //1：p在v的左边
    if(c > 0)return 2;       //2：p在v的右边
    return 0;                //0：p在v上
}
// 点和线段的关系：0 点p不在线段v上；1 点p在线段v上。
bool Point_on_seg(Point p, Line v){
    return sgn(Cross(p-v.p1, v.p2-v.p1)) == 0 && sgn(Dot(p - v.p1,p- v.p2)) <= 0;
}

//两直线关系:0 平行,1 重合,2 相交
int Line_relation(Line v1, Line v2){
    if(sgn(Cross(v1.p2-v1.p1,v2.p2-v2.p1)) == 0){
       if(Point_line_relation(v1.p1,v2)==0)  return 1;//1 重合
       else return 0;//0 平行
    }
    return 2; //2 相交
}

 //点到直线的距离
 double Dis_point_line(Point p, Line v){
    return fabs(Cross(p-v.p1,v.p2-v.p1))/Distance(v.p1,v.p2);
 }

//点在直线上的投影
Point Point_line_proj(Point p, Line v){
    double k=Dot(v.p2-v.p1,p-v.p1)/Len2(v.p2-v.p1);
    return v.p1+(v.p2-v.p1)*k;
}

//点p对直线v的对称点
Point Point_line_symmetry(Point p, Line v){
    Point q = Point_line_proj(p,v);
    return Point(2*q.x-p.x,2*q.y-p.y);
}

//点到线段的距离
double Dis_point_seg(Point p, Segment v){
    if(sgn(Dot(p- v.p1,v.p2-v.p1))<0 || sgn(Dot(p- v.p2,v.p1-v.p2))<0) //点的投影不在线段上
        return min(Distance(p,v.p1),Distance(p,v.p2));
    return Dis_point_line(p,v); //点的投影在线段上
 }

 //求两直线ab和cd的交点
//调用前要保证两直线不平行或重合
 Point Cross_point(Point a,Point b,Point c,Point d){ //Line1:ab,  Line2:cd
    double s1 = Cross(b-a,c-a);
    double s2 = Cross(b-a,d-a);  //叉积有正负
    return Point(c.x*s2-d.x*s1,c.y*s2-d.y*s1)/(s2-s1);
 }
 //两线段是否相交：1 相交，0不相交
bool Cross_segment(Point a,Point b,Point c,Point d){//Line1:ab,  Line2:cd
    double c1=Cross(b-a,c-a),c2=Cross(b-a,d-a);
    double d1=Cross(d-c,a-c),d2=Cross(d-c,b-c);
    return sgn(c1)*sgn(c2)<0 && sgn(d1)*sgn(d2)<0;//注意交点是端点的情况不算在内
}
```

#### 平面几何：多边形 模板

```cpp
//---------------平面几何：多边形----------------
struct Polygon{
    int n;   //多边形的顶点数
    Point p[maxp];   //多边形的点
    Line v[maxp];    //多边形的边
};
//判断点和任意多边形的关系: 3 点上; 2 边上; 1 内部; 0 外部
int Point_in_polygon(Point pt,Point *p,int n){ //点pt，多边形Point *p
    for(int i = 0;i < n;i++){  //点在多边形的顶点上
        if(p[i] == pt)return 3;
    }
    for(int i = 0;i < n;i++){//点在多边形的边上
        Line v=Line(p[i],p[(i+1)%n]);
        if(Point_on_seg(pt,v)) return 2;
    }
    int num = 0;
    for(int i = 0;i < n;i++){
        int j = (i+1)% n;
        int c = sgn(Cross(pt-p[j],p[i]-p[j]));
        int u = sgn(p[i].y - pt.y);
        int v = sgn(p[j].y - pt.y);
        if(c > 0 && u < 0 && v >=0) num++;
        if(c < 0 && u >=0 && v < 0) num--;
    }
    return num != 0; //1 内部; 0 外部
}

double Polygon_area(Point *p, int n){ //Point *p表示多边形。从原点开始划分三角形
    double area = 0;
    for(int i = 0;i < n;i++)
        area += Cross(p[i],p[(i+1)%n]);
    return area/2;    //面积有正负，不能简单地取绝对值
}

Point Polygon_center(Point *p, int n){ //求多边形重心。Point *p表示多边形。
    Point ans(0,0);
    if(Polygon_area(p,n)==0) return ans;
    for(int i = 0;i < n;i++)
        ans = ans + (p[i]+p[(i+1)%n]) * Cross(p[i],p[(i+1)%n]); //面积有正负
    return ans/Polygon_area(p,n)/6.;
}

//Convex_hull()求凸包。凸包顶点放在ch中，返回值是凸包的顶点数
int Convex_hull(Point *p,int n,Point *ch){
    sort(p,p+n);         //对点排序：按x从小到大排序，如果x相同，按y排序
    n=unique(p,p+n)-p;   //去除重复点
    int v=0;
    //求下凸包。如果p[i]是右拐弯的，这个点不在凸包上，往回退
    for(int i=0;i<n;i++){
        while(v>1 && sgn(Cross(ch[v-1]-ch[v-2],p[i]-ch[v-2]))<=0)
            v--;
        ch[v++]=p[i];
    }
    int j=v;
    //求上凸包
    for(int i=n-2;i>=0;i--){
        while(v>j && sgn(Cross(ch[v-1]-ch[v-2],p[i]-ch[v-2]))<=0)
            v--;
        ch[v++]=p[i];
    }
    if(n>1) v--;
    return v;   //返回值v是凸包的顶点数
}
```

#### 平面几何：圆 模板

```cpp
//---------------平面几何：圆----------------
struct Circle{
    Point c;//圆心
    double r;//半径
    Circle(){}
    Circle(Point c,double r):c(c),r(r){}
    Circle(double x,double y,double _r){c=Point(x,y);r = _r;}
};

//点和圆的关系: 0 点在圆内, 1 圆上, 2 圆外.
int Point_circle_relation(Point p, Circle C){
    double dst = Distance(p,C.c);
    if(sgn(dst - C.r) < 0) return 0;  //点在圆内
    if(sgn(dst - C.r) ==0) return 1;   //圆上
    return 2;   //圆外
}

//直线和圆的关系：0 直线在圆内, 1 直线和圆相切, 2 直线在圆外
int Line_circle_relation(Line v,Circle C){
    double dst = Dis_point_line(C.c,v);
    if(sgn(dst-C.r) < 0) return 0; //直线在圆内
    if(sgn(dst-C.r) ==0) return 1;  //直线和圆相切
    return 2; //直线在圆外
}

//线段和圆的关系：0 线段在圆内, 1 线段和圆相切, 2 线段在圆外
int Seg_circle_relation(Segment v,Circle C){
    double dst = Dis_point_seg(C.c,v);
    if(sgn(dst-C.r) < 0) return 0; //线段在圆内
    if(sgn(dst-C.r) ==0) return 1;  //线段和圆相切
    return 2;    //线段在圆外
}

//直线和圆的交点   hdu 5572
int Line_cross_circle(Line v,Circle C,Point &pa,Point &pb){//pa, pb是交点。返回值是交点个数
    if(Line_circle_relation(v, C)==2) return 0;//无交点
    Point q = Point_line_proj(C.c,v);  //圆心在直线上的投影点
    double d = Dis_point_line(C.c,v);   //圆心到直线的距离
    double k = sqrt(C.r*C.r-d*d);   //
    if(sgn(k) == 0){   //1个交点，直线和圆相切
        pa = q;
        pb = q;
        return 1;
    }
    Point n=(v.p2-v.p1)/ Len(v.p2-v.p1);  //单位向量
    pa = q + n*k;
    pb = q - n*k;
    return 2;//2个交点
}
```

#### 三维几何 模板

```cpp
//-------------------三维几何----------------
//三维：点
struct Point3{
    double x,y,z;
    Point3(){}
    Point3(double x,double y,double z):x(x),y(y),z(z){}
    Point3 operator + (Point3 B){return Point3(x+B.x,y+B.y,z+B.z);}
    Point3 operator - (Point3 B){return Point3(x-B.x,y-B.y,z-B.z);}
    Point3 operator * (double k){return Point3(x*k,y*k,z*k);}
    Point3 operator / (double k){return Point3(x/k,y/k,z/k);}
    bool operator == (Point3 B){return sgn(x-B.x)==0 && sgn(y-B.y)==0 && sgn(z-B.z)==0;}
};
typedef Point3 Vector3;
//点积。和二维点积函数同名。C++允许函数同名。
double Dot(Vector3 A,Vector3 B){return A.x*B.x+A.y*B.y+A.z*B.z;}
//叉积
Vector3 Cross(Vector3 A,Vector3 B){return Point3(A.y*B.z-A.z*B.y,A.z*B.x-A.x*B.z,A.x*B.y-A.y*B.x);}
double Len(Vector3 A){return sqrt(Dot(A,A));}   //向量的长度
double Len2(Vector3 A){return Dot(A,A);}        //向量长度的平方
double Distance(Point3 A,Point3 B){
    return sqrt((A.x-B.x)*(A.x-B.x)+(A.y-B.y)*(A.y-B.y)+(A.z-B.z)*(A.z-B.z));
}
double Angle(Vector3 A,Vector3 B){return acos(Dot(A,B)/Len(A)/Len(B));}   //A与B的夹角
//三维：线
struct Line3{
    Point3 p1,p2;
    Line3(){}
    Line3(Point3 p1,Point3 p2):p1(p1),p2(p2){}
};
typedef Line3 Segment3;   //定义线段，两端点是Point p1,p2

//三角形面积的2倍
double Area2(Point3 A,Point3 B,Point3 C){return Len(Cross(B-A, C-A));}

//三维：点到直线距离
double Dis_point_line(Point3 p, Line3 v){
    return Len(Cross(v.p2-v.p1,p-v.p1))/Distance(v.p1,v.p2);
}

//三维：点在直线上
bool Point_line_relation(Point3 p,Line3 v){
    return sgn( Len(Cross(v.p1-p,v.p2-p))) == 0 && sgn(Dot(v.p1-p,v.p2-p))== 0;
}
//三维：点到线段距离。
double Dis_point_seg(Point3 p, Segment3 v){
    if(sgn(Dot(p- v.p1,v.p2-v.p1)) < 0 || sgn(Dot(p- v.p2,v.p1-v.p2)) < 0)
        return min(Distance(p,v.p1),Distance(p,v.p2));
    return Dis_point_line(p,v);
}
//三维：点 p 在直线上的投影
Point3 Point_line_proj(Point3 p, Line3 v){
    double k=Dot(v.p2-v.p1,p-v.p1)/Len2(v.p2-v.p1);
    return v.p1+(v.p2-v.p1)*k;
}
//三维：平面
struct Plane{
    Point3 p1,p2,p3;//平面上的三个点
    Plane(){}
    Plane(Point3 p1,Point3 p2,Point3 p3):p1(p1),p2(p2),p3(p3){}
};
//平面法向量
Point3 Pvec(Point3 A,Point3 B,Point3 C){ return Cross(B-A,C-A);}
Point3 Pvec(Plane f){ return Cross(f.p2-f.p1,f.p3-f.p1);}
//四点共平面
bool Point_on_plane(Point3 A,Point3 B,Point3 C,Point3 D){
    return sgn(Dot(Pvec(A,B,C),D-A)) == 0;
}
//两平面平行
int Parallel(Plane f1, Plane f2){
    return Len(Cross(Pvec(f1),Pvec(f2))) < eps;
}
//两平面垂直
int Vertical (Plane f1, Plane f2){
    return sgn(Dot(Pvec(f1),Pvec(f2)))==0;
}
//直线与平面的交点p，返回值是交点个数
int Line_cross_plane(Line3 u,Plane f,Point3 &p){
    Point3 v = Pvec(f);
    double x = Dot(v, u.p2-f.p1);
    double y = Dot(v, u.p1-f.p1);
    double d = x-y;
    if(sgn(x) == 0 && sgn(y) == 0) return -1;//-1：v在f上
    if(sgn(d) == 0)return 0;                  //0：v与f平行
    p = ((u.p1 * x)-(u.p2 * y))/d;             //v与f相交
    return 1;
}

//四面体有向体积*6
double volume4(Point3 A,Point3 B,Point3 C,Point3 D){return Dot(Cross(B-A,C-A),D-A);}
```

#### 使用示例

```cpp
int main(){
    Point a(0,1),b(0,0),c(1,1),d(1,2),p(1.5,1);
    double a1=5,b1=6,c1=1;
    Line k(a,b),k2(c,d);
    Point pr(1,1),cr(1,1); double r=1; Circle C(cr,r);

    cout<<endl<<"Line_circle_relation="<<Line_circle_relation(k,C);
    cout<<endl<<"Seg_circle_relation="<<Seg_circle_relation(k,C);
    cout<<endl<<"Point_circle_relation="<<Point_circle_relation(pr,C);
    cout<<endl<<"parallel="<<Parallel(a,b)<<endl;
    cout<<"dot="<<Dot(a,b)<<endl<<" angle="<<Angle(a,b)<<endl;
    cout<<"90:"<<sgn(Rotate(a, -pi/2).x)<<endl<<Rotate(a, -pi/2).y;
    cout<<endl<<"line angle="<<Line_angle(k)*4;
    cout<<endl<<"line place="<<Point_line_relation(p,k);
    cout<<endl<<"point_on_seg="<<Point_on_seg(p,k);
    cout<<endl<<"dis_point_line="<<Dis_point_line(p,k);
    cout<<endl<<"dis_point_line="<<Dis_point_seg(p,k);
    Point pp=Cross_point(a,b,c,d);
    cout<<endl<<"crosspoint="<<pp.x<<"  "<<pp.y;
    cout<<endl<<"cross seg="<<Cross_segment(a,b,c,d);
    cout<<endl<<"distance="<<Distance(a,b);
    cout<<endl<<"line_relation="<<Line_relation(k,k2);
    Point g[4];
    g[0]=a;g[1]=b;g[2]=c;g[3]=d;
    cout<<endl<<"Point_in_polygon="<<Point_in_polygon(p,g,4);
    cout<<endl<<"Polygon_area="<<Polygon_area(g,4);
    cout<<endl<<endl;
    return 0;
}
```
