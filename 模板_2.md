# :hatching_chick: :frog: :chicken: 叽叽喳喳动物园模板_2

---

[TOC]

---

## 搜索技术

### BFS

#### 双向广搜

##### 双向广搜 模板

> 2020-3-11 :frog: 整理

```cpp
// 双向广搜
void TBFS(){
   if(/*起点等于终点*/){
          found=true;
          return;
   }
   bool found=false;
   memset(visited,0,sizeof(visited));  // 判重数组
   visited[s1.x][s1.y]=1;   // 初始状态标记为1
   visited[s2.x][s2.y]=2;   // 结束状态标记为2
   Q1.push(s1);  // 初始状态入正向队列
   Q2.push(s2);  // 结束状态入反向队列
   while(!Q1.empty() || !Q2.empty()){
        if(!Q1.empty())
           BFS_expand(Q1,true);  // 在正向队列中搜索
        if(found)  // 搜索结束
            return ;
        if(!Q2.empty())
             BFS_expand(Q2,false);  // 在反向队列中搜索
        if(found) // 搜索结束
            return ;
   }
}
void BFS_expand(queue<Status> &Q,bool flag){// 这里可以去掉queue的引用传递改为全局变量方便一点
    s=Q.front();  // 从队列中得到头结点s
    Q.pop()
    for(/*每个s 的子节点 t*/){
        t.state=Gethash(t.temp)  // 获取子节点的状态
        if(flag){// 在正向队列中判断
            if (visited[t.state]!=1){// 没在正向队列出现过
                if(visited[t.state]==2) {// 该状态在反向队列中出现过
                    /*各种操作*/
                    found=true；
                    return;
                }
                visited[t.state]=1;   // 标记为在在正向队列中
                Q.push(t);  // 入队
            }
        }else{// 在正向队列中判断
            if (visited[t.state]!=2){// 没在反向队列出现过
                if(visited[t.state]==1){// 该状态在正向向队列中出现过
                    /*各种操作*/
                    found=true；
                    return;
                }
                visited[t.state]=2;  // 标记为在反向队列中
                Q.push(t);  // 入队
            }
        }
    }
}
```

### DFS

#### IDAstar

##### IDAstar 模板

> 2020-3-15 :frog: 整理

```cpp
#include<iostream>
#include<cmath>

using namespace std;

const int BEGINX = 0, BEGINY = 0, ENDX = 5, ENDY = 5, MAXH = 5;// 限制最大深度

int manhattanDistance(int x1, int y1, int x2, int y2) {
    return (abs(x1 - x2) + abs(y1 - y2));
}

bool idastar(int x, int y, int l, int maxL){
    if(l > maxL) return false;
    if(/*终点*/){
        return true;
    }
    if((l + manhattanDistance(x, y, ENDX, ENDY)) >= MAXH) return false;// 这是核心剪枝
    /*
    DFS操作
    */
    return false;
}

int main(){
    int maxl = 1;
    while(!idastar(BEGINX, BEGINY, 0, maxl)){
        maxl++;
    }
    return 0;
}
```

## 基础算法思想

### 分治法

#### 归并排序

##### 归并排序 模板

> 2020-2-20 :hatching_chick: 整理

```cpp
#include<bits/stdc++.h>

using namespace std;
void mergearray(int a[], int l , int mid, int r, int temp[]){ //将两个有序数组合并排序

    int i = l, j = mid + 1;
    int m = mid,  n = r;
    int k = 0;
    while(i <= m && j <= n) {
        if(a[i] < a[j])
            temp[k++] = a[i++];
        else
            temp[k++] = a[j++];
    }
    //将剩余的元素存放到临时数组中
    while(i <= m)
        temp[k++] = a[i++];
    while( j <= n)
        temp[k++] = a[j++];
    for(int i = 0; i < k; i++) //临时存放数组的元素存放到原数组中
        a[l + i] = temp[i];

}

void mergesort(int a[], int l, int r, int temp[]){ //将任意两个数组合并排序
    if(l < r) {
        int mid = (l + r) / 2;
        mergesort(a,l,mid,temp); //左边有序
        mergesort(a,mid+1,r,temp); // 右边有序
        mergearray(a,l,mid,r,temp); //将两个有序的数组合并
    }
}

int main(){
    int a[1005];
    int temp[1005];
    int n;
    scanf("%d",&n);
    for(int i = 0; i < n; i++) {
        scanf("%d",&a[i]);
    }
    mergesort(a,0,n-1,temp);
    for(int i = 0 ;i < n; i++) {
        printf("%d ", a[i]);
    }
    return 0;
}
```

##### 归并排序求逆序对 模板

> 2020-2-20 :hatching_chick: 整理

```cpp
#include<iostream>

using namespace std;
const int MAXN = 100005;
typedef long long ll;
ll a[MAXN], b[MAXN], cnt;
void mergearray(ll l, ll mid, ll r){ //将两个有序数组合并排序
    ll i = l, j = mid + 1, t = 0;
    while(i <= mid && j <= r) {
        if(a[i] > a[j]) {
            b[t++] = a[j++];
            cnt += mid - i + 1; //记录逆序对数量
        }
        else
            b[t++] = a[i++];
    }
    //将剩余的元素存放到临时数组中
    while(i <= mid)
        b[t++] = a[i++];
    while(j <= r)
        b[t++] = a[j++];
    for(ll i = 0; i < t; i++) //临时存放数组的元素存放到原数组中
        a[l + i] = b[i];
}

void mergesort(ll l, ll r){ //将任意两个数组合并排序
    if(l < r) {
        ll mid = (l + r) / 2;
        mergesort(l,mid); //左边有序
        mergesort(mid+1,r); // 右边有序
        mergearray(l,mid,r); //将两个有序的数组合并
    }
}

int main(){
    ll n,k;
    while(~scanf("%lld %lld", &n, &k)){
        for(ll i = 0; i < n; i++) {
            scanf("%lld",&a[i]);
        }
        cnt = 0;
        mergesort(0,n-1);
        if(cnt <= k) printf("0\n");
        else printf("%I64d\n", cnt-k);
    }
    return 0;
}
```

#### 快速排序

##### 快速排序模板

> 2020-2-23 :hatching_chick: 整理

```cpp
#include<bits/stdc++.h>

using namespace std;

//数组打印
void print(int a[], int n){
    for(int i = 0; i < n; i++) {
        cout<<a[i]<<" ";
    }
    cout<<endl;
}

//找到每次的基数位置
int quickposition(int s[], int l, int r){
    int i = l, j = r, x = s[l]; // 以最左元素为基数
    while(i < j) {
        //从右向左找到第一个小于x的数
        while(i < j && s[j] >= x) {
            j--;
        }
        if(i < j) {
            s[i] = s[j]; // 直接替换掉最左元素 最左元素已经备份于x
            i++;
        }
        //从左向右找第一个大于x的数
        while(i < j && s[i] <= x) {
            i++;
        }
        if(i < j) {
            s[j] = s[i]; // 替换掉最右元素，最左元素已替换
            j--;
        }
    }
    s[i] = x; // i的位置放x，其左侧元素都小于x，右侧元素都大于x
    return i;
}

void quickSort(int s[], int l, int r){
    //数组左界小于右界才有意义，否则说明都已排好，直接返回即可。
    if(l >= r) {
        return;
    }

    //划分 找到基数位置
    int i = quickposition(s,l,r);

    //递归处理左右俩部分 i为分界点
    quickSort(s,l,i-1);
    quickSort(s,i+1,r);
}

int main(){
    int arr[] = {72,6,57,88,60,42,83,73,48,85};
    print(arr,10);
    quickSort(arr,0,9); //最后一个参数为n-1
    print(arr,10);
    return 0;
}
```

## 动态规划

### 基础 DP

#### 硬币问题

##### 不限定硬币数量求每个金额最小硬币数 模板

> 2020-3-12 :hatching_chick: 整理

```cpp
/*
    以下为不限定硬币数量 求每个金额的最小硬币数量
*/
const int MONEY = 251; //定义最大金额
const int value = 5; //5种硬币
int type[value] = {1, 5, 10, 25, 50};//5种面值
int Min[MONEY]; //每个金额对应最少的硬币数量
int Min_path[MONEY] = {0}; //记录最少硬币的路径
void solve(){
    for(int i = 0; i < MONEY; i++) { //初始值为无穷大
        Min[i] = INT_MAX;
    }
    Min[0] = 0;
    for(int i = 0; i < value; i++) {
        for(int j = type[i]; j < MONEY; j++) {
            if(Min[j] > Min[j - type[i]] + 1) {
                Min_path[j] = type[i]; // 在每个金额上记录路径，即某个硬币的面值
                Min[j] = Min[j - type[i]] + 1;
            }
            Min[j] = min(Min[j],Min[j - type[i]] + 1);
        }
    }
}

void print(int *Min_path, int s) { //打印硬币组合
    while(s){
        cout<<Min_path[s]<<" ";
        s = s - Min_path[s];
    }
}
```

##### 限定硬币数量求一种金额的所有组合方案 模板

> 2020-3-12 :hatching_chick: 整理

```cpp
/*
    以下为限定硬币数量 求该金额所对应的所有组合方案数
*/
const int COIN = 101; //要求不超过的硬币数量
const int MONEY = 251; //给定的钱数不超过的金额
int dp[MONEY][COIN] = {0};
int type[5] = {1, 5, 10, 25, 50};
void solve(){
    dp[0][0] = 1;
    for(int i = 0; i < 5; i++) {
        for(int j = 1;j < COIN; j++) {
            for(int k = type[i]; k < MONEY; k++) {
                dp[k][j] += dp[k - type[i]][j-1];
            }
        }
    }
}

int main(){
    int ans[MONEY] = {0}; //记录对应金额的方案
    solve();
    for(int i = 0; i < MONEY; i++) {
        for(int j = 0; j < COIN; j++) {
            ans[i] += dp[i][j];
        }
    }
}
```

#### 最长公共子序列

##### 最长公共子序列 O(mn) 模板

> 2020-2-20 :frog: 整理

```cpp
int dp[1009][1009] = {0};
string strA, strB;

// 最长公共序列 非子串
int lcs(){
    memset(dp, 0, sizeof(dp));
    for(int i = 1; i <= strA.length(); i++){// 注意从1开始
        for(int j = 1; j <= strB.length(); j++){
            if(strA[i - 1] == strB[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
            else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
        }
    }
    return dp[strA.length()][strB.length()];
}
```

##### 最长公共子序列 滚动 模板

> 2020-2-20 :frog: 整理

```cpp
// 最长公共序列 非子串 滚动
int lcs(){
    memset(dp, 0, sizeof(dp));
    bool nowR = 1, preR = 0;
    for(int i = 0; i < strA.length(); i++){
        int j = 0;
        for(swap(nowR, preR), j = 0; j < strB.length(); j++){
            if(strA[i] == strB[j]) dp[nowR][j + 1] = dp[preR][j] + 1;
            else dp[nowR][j + 1] = dp[preR][j + 1] > dp[nowR][j] ? dp[preR][j + 1] : dp[nowR][j];
        }
    }
    return dp[nowR][strB.length()];
}
```

### 递推与记忆化搜索

#### 递推

##### 数塔最大和问题递推 模板

> 2020-2-23 :chicken: 整理

```cpp
int a[150][150];// a[i][j]是数塔第 i 层的第 j 个数
int dp[150][150];//dp[i][j]记录从第 i 层第 j 个数开始向下可以得到的最大值
for (int j = 1; j <= n; j++) {
    dp[n][j] = a[n][j];
}
for (int i = n - 1; i > 0; i--) {
    for (int j = 1; j <= i; j++) {
        dp[i][j] = a[i][j] + max(dp[i+1][j], dp[i+1][j+1]);
    }
}
return dp[1][1];
```

#### 递归+记忆化搜索

##### 数塔最大和问题递归+记忆化搜索 模板

> 2020-2-23 :chicken: 整理

```cpp
int a[150][150];// a[i][j]是数塔第 i 层的第 j 个数
int dp[150][150];//dp[i][j]记录从第 i 层第 j 个数开始向下可以得到的最大值，初始化为 -1
int dfs(int i, int j) {
    if (i == n) return a[i][j];
    if (dp[i][j] >= 0) return dp[i][j];
    dp[i][j] = max(dfs(i+1, j), dfs(i+1, j+1)) + a[i][j];
    return dp[i][j];
}
```

### 区间 DP

#### 回文串

##### 得到回文串的最小花费 模板

> 2020-3-12 :chicken: 整理

```cpp
int m;// 给定字符串的长度
char s[m];// 字符串
int n;// 字符串中出现的小写字母个数
int w[26];// 每个小写字母对应的改变价值（给定的增加或删除价值中的较小者）
int dp[m][m];// 区间 i, j 变成回文的最小花费
for (int i = m - 1; i >= 0; i--) {
    // i 是子区间起点
    for (int j = i + 1; j > m; j++) {
        // j 是子区间终点
        // 如果区间两端相同，说明已经是回文串
        if (s[i] == s[j]) dp[i][j] = dp[i+1][j-1];
        // 否则改变其中一个位置，变成回文串
        else dp[i][j] = min(dp[i+1][j] + w[s[i]-'a'], dp[i][j-1] + w[s[j]-'a']);
    }
}
return dp[0][m-1];
```

## 数学

### 高精度计算

> 2020-3-21 :hatching_chick: 整理

#### 加法 模板

```cpp
#include <iostream>
#include <cstring>
using namespace std;

struct HugeInt{
    int len;
    int num[100001];
};

HugeInt a, b, w;        //w为结果
char c[100001], d[100001];

void Scan_HugeInt() {   //读入两个大整数
    cin >> c;
    cin >> d;
    a.len = strlen(c); //strlen求串长
    b.len = strlen(d);
    for(int i=0; i<a.len; i++) a.num[a.len - i] = c[i] - '0'; //逆序存储
    for(int i=0; i<b.len; i++) b.num[b.len - i] = d[i] - '0';
}

void Plus() {
    w.len = max(a.len, b.len);           //num每一位是0，长度取max不影响加法
    for(int i=1; i<=w.len; i++) {
        w.num[i] += a.num[i] + b.num[i];
        w.num[i+1] += w.num[i] / 10;    //处理进位
        w.num[i] %= 10;                 //处理当前位 保证<10
    }
    if(w.num[w.len + 1] != 0) w.len ++;  //加法最多有可能会多出一位
}

int main() {
    Scan_HugeInt();
    Plus();
    for(int i=w.len; i>=1; i--) cout << w.num[i]; //倒序存储 倒序输出
    cout << endl;
    return 0;
}
```

#### 减法 模板

```cpp
#include <iostream>
#include <cstring>
using namespace std;

struct HugeInt {
    int len;
    int num[100001];
};

HugeInt a, b, w;         //w为结果
char c[100001], d[100001];
bool negative;           //负数标记

void Scan_HugeInt() {    //读入两个大整数
    cin >> c;
    cin >> d;
    if((strlen(c) < strlen(d)) || (strlen(c) == strlen(d) && strcmp(c, d) < 0)) { //若被减数小 交换 记为负数
        negative = true;
        swap(c, d);
    }
    a.len = strlen(c);
    b.len = strlen(d);
    for(int i=0; i<a.len; i++) a.num[a.len - i] = c[i] - '0';
    for(int i=0; i<b.len; i++) b.num[b.len - i] = d[i] - '0';
}

void Minus() {
    w.len = a.len;                //a更大
    for(int i=1; i<=w.len; i++) {
        if(a.num[i] < b.num[i]) {
            a.num[i+1] --;      //num[i+1]减成负数也不影响
            a.num[i] += 10;     //借位
        }
        w.num[i] += a.num[i] - b.num[i];
    }
    while(w.num[w.len] == 0 && (w.len != 1)) w.len --; //多余的不是个位的0去掉
}

int main() {
    Scan_HugeInt();
    Minus();
    if(negative == true) cout << "-";             //负数加负号
    for(int i=w.len; i>=1; i--) cout << w.num[i]; //倒序存储 倒序输出
    cout << endl;
    return 0;
}
```

#### 乘法 模板

```cpp
#include <iostream>
#include <cstring>
using namespace std;

struct HugeInt {
    int len;
    int num[100001];
};

HugeInt a, b, w;
char c[10001], d[10001];

void Scan_HugeInt() {    //读入两个大整数
    cin >> c;
    cin >> d;
    a.len = strlen(c);
    b.len = strlen(d);
    for(int i=0; i<a.len; i++) a.num[a.len - i] = c[i] - '0';
    for(int i=0; i<b.len; i++) b.num[b.len - i] = d[i] - '0';
}

void Multiply() {
    int x;              //处理每次进位的变量
    for(int i=1; i<=a.len; i++) {      //a的第i位
        x = 0;
        for(int j=1; j<=b.len; j++) { //b的第j位
            w.num[i+j-1] += a.num[i] * b.num[j] + x; //用 +=:结果与上次乘的结果相加
            x = w.num[i+j-1] / 10;
            w.num[i+j-1] %= 10;          //进位处理
        }
        w.num[i+b.len] = x;  //多出的最高位
    }
    w.len = a.len + b.len;
    while(w.num[w.len] == 0 && (w.len != 1)) w.len --; //多余的0
}

int main() {
    Scan_HugeInt();
    Multiply();
    for(int i=w.len; i>=1; i--) cout << w.num[i];
    cout << endl;
    return 0;
}
```

### 数论

#### 快速幂

##### 矩阵快速幂 模板

> 2020-3-15 :frog: 整理

斐波那契数列的另一个公式是：

$\begin{bmatrix}F_{n+1} & F_n\\F_n & F_{n-1}\\\end{bmatrix} =\begin{bmatrix}1 & 1\\1 & 0\\\end{bmatrix}^n = \underbrace{\begin{bmatrix}1 & 1\\1 & 0\\\end{bmatrix} + \begin{bmatrix}1 & 1\\1 & 0\\\end{bmatrix} \cdots \begin{bmatrix}1 & 1\\1 & 0\\\end{bmatrix}}_\text{n times}$

```cpp
#include<iostream>
#include<string>
#include<cstring>
using namespace std;

const int MAXN = 2; //矩阵的阶
const int MOD = 10000;//题目要求模

struct Matrix{
    int m[MAXN][MAXN];
    Matrix(){
        memset(m, 0, sizeof(m));
    }
    Matrix operator *(Matrix a){// 矩阵乘法
        Matrix res;
        for(int i = 0; i < MAXN; i++){
            for(int j = 0; j < MAXN; j++){
                for(int k = 0; k < MAXN; k++){
                    res.m[i][j] = (res.m[i][j] + m[i][k] * a.m[k][j]) % MOD;
                }
            }
        }
        return res;
    }
};

int MPow(Matrix a, int n){// 矩阵快速幂
    Matrix res;
    for(int i = 0; i < MAXN; i++) res.m[i][i] = 1;
    while(n){
        if(n & 1) res = res * a;
        a = a * a;
        n >>= 1;
    }
    return res.m[0][1];
}

int main(){
    int n;
    while(cin>>n){
        if(n == -1) return 0;
        Matrix a;
        a.m[0][0] = 1;
        a.m[0][1] = 1;
        a.m[1][0] = 1;
        a.m[1][1] = 0;
        cout<<MPow(a, n)<<endl;
    }
    return 0;
}
```

#### 扩展欧几里得算法与二元一次方程的整数解

##### 扩展欧几里得算法求解二元一次方程 模板

> 2020-3-16 :hatching_chick: 整理

```cpp
#include<bits/stdc++.h>

using namespace std;
//满足ax + by = gcd(a,b) 可求得一个点(x0,y0);
int  extend_gcd(int a, int b, int &x, int &y){
    if(b == 0) {
        x = 1, y = 0;
        return a;
    }

    int d = extend_gcd(b,a%b,x,y);
    int tmp = x;
    x = y;
    y = tmp - (a / b) * y;
    return d; //得到a，b的最大公因数
}

int main(){
    int a, b, c;
    scanf("%d%d%d",&a,&b,&c); //ax + by = c  满足ax + by = gcd(a,b)
    int x, y, d;
    d = extend_gcd(a,b,x,y);  //得到a，b的最大公因数
    if(c % d != 0 ) printf("No solution!\n");
    else {
        a /= d, b /= d, c /= d;
        x *= c, y *= c;
        printf("特解: %d %d\n",x,y);
        printf("一个通解: %d %d\n",x+b,y-a);
    }
    return 0;
}
```

### 组合数学

#### 杨辉三角和二项式系数

##### 求杨辉三角的某项或某行 模板

> 2020-3-15 :chicken: 整理

```cpp
#include<vector>

typedef long long ll;

/**
 * 得到杨辉三角第 n 行，第 m 项，0 <= m <= n
 * 塔尖为第 0 行，第 0 项
 * re *= (n - prev + 1) 此处可能溢出，所以需确保 n <= 61
 * 利用二项式系数与杨辉三角中项的关系进行计算
 */
ll getGen(int n, int m) {
    if (m == 0 || m == n) return 1;
    ll re = 1;
    for (int prev = 1; prev <= m; prev++) {
        re *= (n - prev + 1);
        re /= prev;
    }
    return re;
}

/**
 * 得到杨辉三角第 n 行，结果放在 ans[] 中
 * 约定 ans 的长度为 n+1 ，塔尖为第 0 行
 * ans[prev] = ans[prev-1] * (n - prev + 1) 此处可能溢出，所以需确保 n <= 61
 * 利用二项式系数与杨辉三角中项的关系进行计算
 */
void getGens(int n, vector<ll> &ans) {
    ans[0] = 1;
    ans[n] = 1;
    for (int prev = 1; prev < n; prev++) {
        ans[prev] = ans[prev-1] * (n - prev + 1);
        ans[prev] /= prev;
    }
}
```

#### 母函数

##### 普通型母函数求整数划分 模板

> 2020-3-23 :chicken: 整理

```cpp
/**
 * 计算后， c1[n] 就是整数 n 的划分数
 */
const int MAXN = 200;
int c1[MAXN+1], c2[MAXN+1];
void part() {
    int i,j,k;
    for (i = 0; i <= MAXN; i++) {
        c1[i] = 1;
        c2[i] = 0;
    }
    for (k = 2; k <= MAXN; k++) {
        for (i = 0; i <= MAXN; i++) {
            for (j = 0; j + i <= MAXN; j += k) {
                c2[i+j] += c1[i];
            }
        }
        for (i = 0; i <= MAXN; i++) {
            c1[i] = c2[i];
            c2[i] = 0;
        }
    }
}
int main() {
    int n;
    part();
    while(cin>>n) cout<<c1[n]<<'\n';
    return 0;
}
```

##### 指数型母函数求排列组合数 模板

> 2020-3-24 :chicken: 整理

指数型母函数的定义：

对序列 $a_0, a_1, a_2, \cdots$

构造函数：

$G(x) = \frac{a_0}{0!}x^0 + \frac{a_1}{1!}x^1 + \frac{a_2}{2!}x^2 + \frac{a_3}{3!}x^3 \cdots$

称 $G(x)$ 为序列 $a_0, a_1, a_2, \cdots$ 的指数型母函数

```cpp
// n 物品种类， m 共选出几种物品， vectorA 每种物品对应的数量
// 过程是对指数型母函数公式的展开
// 过程结束后 c1 的第 i 项代表选 i 件物品时的排列数量 x 除以 i!
double c1[11];
double c2[11];

int main() {
    int n, m;
    vector<double> factorial(11);
    factorial[0] = 1;
    for (int i = 1; i <= 10; i++) {
        factorial[i] = factorial[i-1] * i;
    }

    while (cin>>n>>m) {
        vector<int> vectorA(n+1);
        for (int i = 1; i <= n; i++) {
            cin>>vectorA[i];
        }
        memset(c1, 0, sizeof(c1));
        memset(c2, 0, sizeof(c2));

        for (int i = 0; i <= vectorA[1]; i++) {
            c1[i] = 1.0 / factorial[i];
        }

        for (int i = 2; i <= n; i++) {
            for (int j = 0; j <= m; j++) {
                for (int z = 0; z <= vectorA[i] && j + z <= m; z++) {
                    c2[j+z] += c1[j] / factorial[z];
                }
            }

            for (int j = 0; j <= m; j++) {
                c1[j] = c2[j];
                c2[j] = 0;
            }
        }

        printf("%.lf\n", c1[m]*factorial[m]);
    }
    return 0;
}
```

#### 特殊计数

##### Catalan 数（卡特兰数） 模板 & 解题示例

> 2020-3-27 :chicken: 整理

Catalan 数定义：

$C_n = \frac{1}{n+1} \tbinom{2n}{n}, n = 0, 1, 2, \cdots$

三种计算方法：

* $C_n = C_0C_{n-1} + C_1C_{n-2} + \cdots + C_{n-2}C_1 + C_{n-1}C_0 = \sum_{k = 0}^{n-1}C_kC_{n-k-1}, C_0 = 1$

* $C_n = \frac{4n-2}{n+1} C_{n-1}, C_0 = 1$

* $C_n = \frac{1}{n+1} \tbinom{2n}{n} = \frac{(2n)!}{(n+1)!n!}$

对应问题：

* 棋盘问题
* 括号问题
* 出栈序列问题
* 二叉树问题

```cpp
// HDU 1023
#include<iostream>
#include<cstdio>
#include<cstring>

using namespace std;

// 大数位数
#define MAX 101

// 10000 进制
#define BASE 10000

// 进行大数 a 和 整数 b 的乘法运算，BASE 为基数
void multiply(int a[], int len, int b) {
    for(int i = len - 1, carry = 0; i >= 0; i--) {
        carry += b * a[i];
        a[i] = carry % BASE;
        carry /= BASE;
    }
}

// 进行大数 a 和 整数 b 的除法运算，BASE 为基数
void divide(int a[], int len, int b) {
    for(int i = 0, div = 0; i < len; i++) {
        div = div * BASE + a[i];
        a[i] = div / b;
        div %= b;
    }
}

// 公式二求卡特兰数列前 100 项
int main() {
    // 答案容器， 101 由可得到的最大项数 n 加一得出。求前 n 项，此处应填 n + 1
    int ans[101][MAX];
    memset(ans[1], 0, MAX*sizeof(int));
    // 初始化第一项为 1
    ans[1][MAX-1] = 1;
    // 由公式二计算
    for(int i = 2; i <= 100; i++) {
        memcpy(ans[i], ans[i-1], MAX*sizeof(int));
        multiply(ans[i], MAX, 4*i-2);
        divide(ans[i], MAX, i+1);
    }
    int n;
    while(cin>>n) {
        int j = 0;
        while (j < MAX && ans[n][j] == 0) j++;
        printf("%d", ans[n][j++]);
        while (j < MAX) {
            // 基数为 10000 ，所以需要在位数不足 4 时输出占位 0
            printf("%04d", ans[n][j++]);
        }
        cout<<'\n';
    }
    return 0;
}
```

### 公平组合游戏

#### 巴什游戏与 P-position, N-position

##### 巴什游戏 模板

> 2020-2-23 :frog: 整理

```cpp
/*
巴什游戏
n个石子 甲先取 乙后取 每次可以拿1-m个石子 轮流拿 拿到最后一个石子的人获胜
*/
void solve(){
    int n, m;
    cin>>n>>m;
    if(n % (m + 1) == 0) cout<<"second"<<endl;
    else cout<<"first"<<endl;
}
```

#### 尼姆游戏

##### 尼姆游戏 模板

> 2020-3-18 :frog: 整理

```cpp
#include<iostream>
#include<cmath>

using namespace std;
/*
    尼姆游戏
    地上有n堆石子（每堆石子数量小于10000），
    每人每次可从任意一堆石子里取出任意多枚石子扔掉，可以取完，不能不取。
    每次只能从一堆里取。最后没石子可取的人就输了。
    假如甲是先手，且告诉你这n堆石子的数量，他想知道是否存在先手必胜的策略。
    第一行一个整数n，表示有n堆石子。
    第二行有n个数，表示每一堆石子的数量
*/
int main(){
    int n = 0, temp=0, ret=0;
    cin>>n;
    for(int i = 1; i <= n; i++){
        cin>>temp;
        ret ^= temp;
    }
    if(ret) cout<<"Yes"<<endl;
    else cout<<"No"<<endl;
    return 0;
}
```

#### 威佐夫游戏

##### 威佐夫游戏 模板

> 2020-3-18 :frog: 整理

```cpp
#include<iostream>
#include<cmath>

using namespace std;
/*
    威佐夫游戏
    游戏规定，每次有两种不同的取法，一是可以在任意的一堆中取走任意多的石子；
    二是可以在两堆中同时取走相同数量的石子。最后把石子全部取完者为胜者。
    现在给出初始的两堆石子的数目，如果轮到你先取，假设双方都采取最好的策略，问最后你是胜者还是败者。
    1表示自己是胜者
*/
int main(){
    int n, m;
    double gold = (1 + sqrt(5)) / 2;
    while(cin>>n>>m){
        int a = min(n, m);
        int b = max(n, m);
        double k = (double)(b - a);
        int test = (int)(k * gold);
        if(test == a) cout<<0<<endl;
        else cout<<1<<endl;
    }
    return 0;
}
```

## 字符串

### 字符串哈希

#### 字符串哈希 模板 & 解题示例

> 2020-3-25 :hatching_chick: 整理

```cpp
/*输入若干个店家，和n天涨价的价格，输出n天后memory店的价格在所有店里面的排名
Sample Input
3
memory
kfc
wind
2
49 memory
49 kfc
48 wind
80 kfc
85 wind
83 memory

Sample Output
1
2

*/
#include<bits/stdc++.h>
using namespace std;

const int N = 10005;

struct node {
    char name[35];
    int price;
};

vector<node> List[N]; //用于解决冲突

unsigned int BKDRHash(char *str) { //哈希函数
    unsigned int seed = 31, key = 0;
    while(*str) {
        key = key * seed + (*str++);
    return key & 0x7fffffff;
    }
}

int main() {
    int n, m, key, add, memory_price, rank, len;
    int p[N];
    char s[35];
    node t;
    while(cin>>n) {
        for(int i = 0; i < N; i++) {
            List[i].clear();
        }
        for(int i = 0; i < n; i++) {
            cin>>t.name;
            key = BKDRHash(t.name) % N; //计算hash值 并求余
            List[key].push_back(t); //hash值可能冲突，把冲突的哈希值都存起来
        }
        cin>>m;
        while(m--){
            rank = len = 0;
            for(int i = 0; i < n; i++) {
                cin>>add>>s;
                key = BKDRHash(s) % N; //计算hash值
                for(int j = 0; j < List[key].size(); j++) { //处理冲突问题
                    if(strcmp(List[key][j].name,s) == 0) {
                        List[key][j].price += add;
                        if(strcmp(s,"memory") == 0) {
                            memory_price = List[key][j].price;
                        }else {
                            p[len++] = List[key][j].price;
                        }
                        break;
                    }
                }
            }
            for(int i = 0; i < len; i++) {
                if(memory_price < p[i]) {
                    rank++;
                }
            }
            cout<<rank+1<<endl;
        }
    }
    return 0;
}
```

### AC自动机

#### AC自动机 模板

>2020-3-24 :frog: 整理

```cpp
#include<iostream>
#include<queue>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define MAX_N 1000006
#define MAX_tot 500005

using namespace std;
/*
AC自动机
输入：
1
5
she
he
say
shr
her
yasherhs
输出：
3
*/

struct aho {
    struct state {
        int next[26];
        int fail, cnt;
    }statetable[MAX_tot];
    int size;
    std::queue<int>que;

    void init(){
        while (que.size()) que.pop();
        for (int i = 0;i < MAX_tot;i++){
            memset(statetable[i].next, 0, sizeof(statetable[i].next));
            statetable[i].fail = 0;
            statetable[i].cnt = 0;
        }
        size = 1;
    }
    void insert(char*S){
        int n = strlen(S);
        int now = 0;
        for (int i = 0;i < n;i++){
            char c = S[i];
            if (!statetable[now].next[c - 'a'])
                statetable[now].next[c - 'a'] = size++;
            now = statetable[now].next[c - 'a'];
        }
        statetable[now].cnt++;
    }


    void build(){
        statetable[0].fail = -1;
        que.push(0);

        while (que.size()){
            int u = que.front();
            que.pop();
            for (int i = 0;i < 26;i++){
                if (statetable[u].next[i]){
                    if (u == 0) statetable[statetable[u].next[i]].fail = 0;
                    else{
                        int v = statetable[u].fail;
                        while (v != -1){
                            if (statetable[v].next[i]){
                                statetable[statetable[u].next[i]].fail = statetable[v].next[i];
                                break;
                            }
                            v = statetable[v].fail;
                        }
                        if (v == -1) statetable[statetable[u].next[i]].fail = 0;
                    }
                    que.push(statetable[u].next[i]);
                }
            }
        }
    }

    int get(int u) {
        int res = 0;
        while (u){
            res += statetable[u].cnt;
            statetable[u].cnt = 0;
            u = statetable[u].fail;
        }
        return res;
    }
    int match(char*S){
        int n = strlen(S);
        int res = 0, now = 0;
        for (int i = 0;i < n;i++){
            char c = S[i];
            if (statetable[now].next[c - 'a']) now = statetable[now].next[c - 'a'];
            else {
                int p = statetable[now].fail;
                while (p != -1 && statetable[p].next[c - 'a'] == 0)
                    p = statetable[p].fail;
                if (p == -1)
                    now = 0;
                else
                    now = statetable[p].next[c - 'a'];
            }
            if (statetable[now].cnt)
                res = res + get(now);
        }
        return res;
    }
}aho;

int t;
int n;
char S[MAX_N];
int main(){
    scanf("%d", &t);
    while (t--){
        aho.init();
        scanf("%d", &n);
        for (int i = 0;i < n;i++){
            scanf("%s", S);
            aho.insert(S);
        }
        aho.build();
        scanf("%s", S);
        printf("%d\n", aho.match(S));
    }
    return 0;
}
```

## 计算几何

### 二维几何基础

#### 凸包

##### 凸包 模板 & 解题示例

> 2020-3-22 :frog: 整理

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
/*
    凸包
    给定一些点 求能够把这些点包含在内的面积最小的多边形。
测试用例
9
12 7
24 9
30 5
41 9
80 7
50 87
22 9
45 1
50 7
0
输出用例
243.06
*/
const int maxn = 104;
const double eps = 1e-8;

// 判断x是否等于0
int sgn(double x){
    if(fabs(x) < eps) return 0;
    else return x < 0 ? -1 : 1;
}
struct Point{
    double x, y;
    Point(){}
    Point(double x, double y) : x(x) , y(y){}
    Point operator + (Point B){
        return Point(x + B.x, y + B.y);
    }
    Point operator - (Point B){
        return Point(x - B.x, y - B.y);
    }
    bool operator == (Point B){
        return sgn(x - B.x) == 0 && sgn(y - B.y) == 0;
    }
    bool operator < (Point B){
        return sgn(x - B.x) < 0 || (sgn(x - B.x) == 0 && sgn(y - B.y) < 0);
    }
};

typedef Point Vector;

double Cross(Vector A, Vector B){
    return A.x * B.y - A.y * B.x;
}
double Distance(Point A, Point B){
    return hypot(A.x - B.x, A.y - B.y);
}

// 求凸包
int Convex_hull(Point *p, int n, Point *ch){
    sort(p, p + n);
    n = unique(p, p + n) - p;
    int v = 0;
    for(int i = 0; i < n; i++){
        while(v > 1 && sgn(Cross(ch[v - 1] - ch[v - 2], p[i] - ch[v - 2])) <= 0) v--;
        ch[v++] = p[i];
    }
    int j = v;
    // 求上凸包
    for(int i = n - 2; i >= 0; i--){
        while(v > j && sgn(Cross(ch[v - 1] - ch[v - 2], p[i] - ch[v - 2])) <= 0) v--;
        ch[v++] = p[i];
    }
    if(n > 1) v--;
    return v;
}

int main(){
    int n;
    Point p[maxn], ch[maxn];
    while(scanf("%d", &n) && n){
        for(int i = 0; i < n; i++) scanf("%lf %lf", &p[i].x, &p[i].y);
        int v = Convex_hull(p, n, ch);
        double ans = 0;
        if(v == 1) ans = 0;
        else if(v == 2) ans = Distance(ch[0], ch[1]);
        else{
            for(int i = 0; i < v; i++) ans += Distance(ch[i], ch[(i + 1) % v]);
        }
        printf("%.2lf\n", ans);
    }
}
```

#### 最近点对

##### 求最近点距离 模板

> 2020-3-18 :chicken: 整理

```cpp
/**
 * 计算最近点距离之前要先排序一次 sort(p, p+n, cmpxy)
 */
const double eps = 1e-8;
const int MAXN = 100010;
const double INF = 1e20;

int sgn(double x) {
    if(fabs(x) < eps) return 0;
    else return x < 0 ? -1 : 1;
}

struct Point{
    double x,y;
 };

double Distance(Point A, Point B) {
    return hypot(A.x-B.x,A.y-B.y);
}

// 先对横坐标 x 排序，再对 y 排序
bool cmpxy(Point A,Point B) {
    return sgn(A.x-B.x) < 0 || (sgn(A.x-B.x) == 0 && sgn(A.y-B.y) < 0);
}

// 只对 y 坐标排序
bool cmpy (Point A,Point B) {
    return sgn(A.y-B.y)<0;
}

Point p[MAXN],tmp_p[MAXN];

double Closest_Pair(int left, int right) {
    double dis = INF;
    // 只剩1个点
    if(left == right) return dis;
    // 只剩2个点
    if(left + 1 == right) {
        return Distance(p[left], p[right]);
    }
    // 分治
    int mid = (left + right) / 2;
    // 求s1内的最近点对
    double d1 = Closest_Pair(left, mid);
    // 求s2内的最近点对
    double d2 = Closest_Pair(mid+1, right);
    dis = min(d1, d2);
    int k = 0;

    // 在s1和s2中间附近找可能的最小点对
    for(int i = left; i <= right; i++){
        // 按x坐标来找
        if(fabs(p[mid].x - p[i].x) <= dis) {
            tmp_p[k++] = p[i];
        }
    }

    // 按y坐标排序，用于剪枝。这里不能按x坐标排序
    sort(tmp_p, tmp_p+k, cmpy);
    for(int i = 0; i < k; i++) {
        for(int j = i + 1; j < k; j++) {
            // 剪枝
            if(tmp_p[j].y - tmp_p[i].y >= dis) break;
            dis = min(dis, Distance(tmp_p[i], tmp_p[j]));
        }
    }
    // 返回最小距离
    return dis;
}
```

### 几何模板

> 2020-2-20 :chicken: 整理

#### 公共部分

```cpp
#include <bits/stdc++.h>
using namespace std;
const double pi = acos(-1.0);  //高精度圆周率
const double eps = 1e-8;       //偏差值
const int maxp = 1010;         //点的数量
int sgn(double x){  //判断x是否等于0
    if(fabs(x) < eps)  return 0;
    else return x<0?-1:1;
}
int Dcmp(double x, double y){  //比较两个浮点数：0 相等；-1 小于；1 大于
    if(fabs(x - y) < eps) return 0;
    else return x<y ?-1:1;
}
```

#### 平面几何：点和线 模板

```cpp
//---------------平面几何：点和线--------
struct Point{  //定义点和基本运算
    double x,y;
    Point(){}
    Point(double x,double y):x(x),y(y){}
    Point operator + (Point B){return Point(x+B.x,y+B.y);}
    Point operator - (Point B){return Point(x-B.x,y-B.y);}
    Point operator * (double k){return Point(x*k,y*k);}    //长度增大k倍
    Point operator / (double k){return Point(x/k,y/k);}    //长度缩小k倍
    bool operator == (Point B){return sgn(x-B.x)==0 && sgn(y-B.y)==0;}
    bool operator < (Point B){return sgn(x-B.x)<0 || (sgn(x-B.x)==0 && sgn(y-B.y)<0);} //用于凸包
};
typedef Point Vector;   //定义向量
double Dot(Vector A,Vector B){return A.x*B.x + A.y*B.y;} //点积
double Len(Vector A){return sqrt(Dot(A,A));}   //向量的长度
double Len2(Vector A){return Dot(A,A);}        //向量长度的平方
double Angle(Vector A,Vector B){return acos(Dot(A,B)/Len(A)/Len(B));}   //A与B的夹角
double Cross(Vector A,Vector B){return A.x*B.y - A.y*B.x;} //叉积
double Area2(Point A, Point B, Point C){return Cross(B-A, C-A);} //三角形ABC面积的2倍
double Distance(Point A, Point B){return hypot(A.x-B.x,A.y-B.y);}   //两点的距离
double Dist(Point A,Point B){return sqrt((A.x-B.x)*(A.x-B.x) + (A.y-B.y)*(A.y-B.y));}
Vector Normal(Vector A){return Vector(-A.y/ Len(A), A.x/ Len(A));}  //向量A的单位法向量

bool Parallel(Vector A, Vector B){return sgn(Cross(A,B)) == 0;}//向量平行或重合)

Vector Rotate(Vector A, double rad){  //向量A逆时针旋转rad度
    return Vector(A.x*cos(rad)-A.y*sin(rad), A.x*sin(rad)+A.y*cos(rad));
}

struct Line{
    Point p1,p2;//线上的两个点
    Line(){}
    Line(Point p1,Point p2):p1(p1),p2(p2){}
   // Line(Point x,Point y){p1 = x;p2 = y;}
  //  Point(double x,double y):x(x),y(y){}
//根据一个点和倾斜角 angle 确定直线,0<=angle<pi
    Line(Point p,double angle){
        p1 = p;
        if(sgn(angle - pi/2) == 0){p2 = (p1 + Point(0,1));}
        else{p2 = (p1 + Point(1,tan(angle)));}
    }
//ax+by+c=0
    Line(double a,double b,double c){
        if(sgn(a) == 0){
            p1 = Point(0,-c/b);
            p2 = Point(1,-c/b);
        }
        else if(sgn(b) == 0){
            p1 = Point(-c/a,0);
            p2 = Point(-c/a,1);
        }
        else{
            p1 = Point(0,-c/b);
            p2 = Point(1,(-c-a)/b);
        }
    }
};

typedef Line Segment;   //定义线段，两端点是Point p1,p2

//返回直线倾斜角 0<=angle<pi
double Line_angle(Line v){
    double k = atan2(v.p2.y-v.p1.y, v.p2.x-v.p1.x);
    if(sgn(k) < 0)k += pi;
    if(sgn(k-pi) == 0)k -= pi;
        return k;
}
//点和直线关系:1 在左侧;2 在右侧;0 在直线上
int Point_line_relation(Point p,Line v){
    int c = sgn(Cross(p-v.p1,v.p2-v.p1));
    if(c < 0)return 1;       //1：p在v的左边
    if(c > 0)return 2;       //2：p在v的右边
    return 0;                //0：p在v上
}
// 点和线段的关系：0 点p不在线段v上；1 点p在线段v上。
bool Point_on_seg(Point p, Line v){
    return sgn(Cross(p-v.p1, v.p2-v.p1)) == 0 && sgn(Dot(p - v.p1,p- v.p2)) <= 0;
}

//两直线关系:0 平行,1 重合,2 相交
int Line_relation(Line v1, Line v2){
    if(sgn(Cross(v1.p2-v1.p1,v2.p2-v2.p1)) == 0){
       if(Point_line_relation(v1.p1,v2)==0)  return 1;//1 重合
       else return 0;//0 平行
    }
    return 2; //2 相交
}

 //点到直线的距离
 double Dis_point_line(Point p, Line v){
    return fabs(Cross(p-v.p1,v.p2-v.p1))/Distance(v.p1,v.p2);
 }

//点在直线上的投影
Point Point_line_proj(Point p, Line v){
    double k=Dot(v.p2-v.p1,p-v.p1)/Len2(v.p2-v.p1);
    return v.p1+(v.p2-v.p1)*k;
}

//点p对直线v的对称点
Point Point_line_symmetry(Point p, Line v){
    Point q = Point_line_proj(p,v);
    return Point(2*q.x-p.x,2*q.y-p.y);
}

//点到线段的距离
double Dis_point_seg(Point p, Segment v){
    if(sgn(Dot(p- v.p1,v.p2-v.p1))<0 || sgn(Dot(p- v.p2,v.p1-v.p2))<0) //点的投影不在线段上
        return min(Distance(p,v.p1),Distance(p,v.p2));
    return Dis_point_line(p,v); //点的投影在线段上
 }

 //求两直线ab和cd的交点
//调用前要保证两直线不平行或重合
 Point Cross_point(Point a,Point b,Point c,Point d){ //Line1:ab,  Line2:cd
    double s1 = Cross(b-a,c-a);
    double s2 = Cross(b-a,d-a);  //叉积有正负
    return Point(c.x*s2-d.x*s1,c.y*s2-d.y*s1)/(s2-s1);
 }
 //两线段是否相交：1 相交，0不相交
bool Cross_segment(Point a,Point b,Point c,Point d){//Line1:ab,  Line2:cd
    double c1=Cross(b-a,c-a),c2=Cross(b-a,d-a);
    double d1=Cross(d-c,a-c),d2=Cross(d-c,b-c);
    return sgn(c1)*sgn(c2)<0 && sgn(d1)*sgn(d2)<0;//注意交点是端点的情况不算在内
}
```

#### 平面几何：多边形 模板

```cpp
//---------------平面几何：多边形----------------
struct Polygon{
    int n;   //多边形的顶点数
    Point p[maxp];   //多边形的点
    Line v[maxp];    //多边形的边
};
//判断点和任意多边形的关系: 3 点上; 2 边上; 1 内部; 0 外部
int Point_in_polygon(Point pt,Point *p,int n){ //点pt，多边形Point *p
    for(int i = 0;i < n;i++){  //点在多边形的顶点上
        if(p[i] == pt)return 3;
    }
    for(int i = 0;i < n;i++){//点在多边形的边上
        Line v=Line(p[i],p[(i+1)%n]);
        if(Point_on_seg(pt,v)) return 2;
    }
    int num = 0;
    for(int i = 0;i < n;i++){
        int j = (i+1)% n;
        int c = sgn(Cross(pt-p[j],p[i]-p[j]));
        int u = sgn(p[i].y - pt.y);
        int v = sgn(p[j].y - pt.y);
        if(c > 0 && u < 0 && v >=0) num++;
        if(c < 0 && u >=0 && v < 0) num--;
    }
    return num != 0; //1 内部; 0 外部
}

double Polygon_area(Point *p, int n){ //Point *p表示多边形。从原点开始划分三角形
    double area = 0;
    for(int i = 0;i < n;i++)
        area += Cross(p[i],p[(i+1)%n]);
    return area/2;    //面积有正负，不能简单地取绝对值
}

Point Polygon_center(Point *p, int n){ //求多边形重心。Point *p表示多边形。
    Point ans(0,0);
    if(Polygon_area(p,n)==0) return ans;
    for(int i = 0;i < n;i++)
        ans = ans + (p[i]+p[(i+1)%n]) * Cross(p[i],p[(i+1)%n]); //面积有正负
    return ans/Polygon_area(p,n)/6.;
}

//Convex_hull()求凸包。凸包顶点放在ch中，返回值是凸包的顶点数
int Convex_hull(Point *p,int n,Point *ch){
    sort(p,p+n);         //对点排序：按x从小到大排序，如果x相同，按y排序
    n=unique(p,p+n)-p;   //去除重复点
    int v=0;
    //求下凸包。如果p[i]是右拐弯的，这个点不在凸包上，往回退
    for(int i=0;i<n;i++){
        while(v>1 && sgn(Cross(ch[v-1]-ch[v-2],p[i]-ch[v-2]))<=0)
            v--;
        ch[v++]=p[i];
    }
    int j=v;
    //求上凸包
    for(int i=n-2;i>=0;i--){
        while(v>j && sgn(Cross(ch[v-1]-ch[v-2],p[i]-ch[v-2]))<=0)
            v--;
        ch[v++]=p[i];
    }
    if(n>1) v--;
    return v;   //返回值v是凸包的顶点数
}
```

#### 平面几何：圆 模板

```cpp
//---------------平面几何：圆----------------
struct Circle{
    Point c;//圆心
    double r;//半径
    Circle(){}
    Circle(Point c,double r):c(c),r(r){}
    Circle(double x,double y,double _r){c=Point(x,y);r = _r;}
};

//点和圆的关系: 0 点在圆内, 1 圆上, 2 圆外.
int Point_circle_relation(Point p, Circle C){
    double dst = Distance(p,C.c);
    if(sgn(dst - C.r) < 0) return 0;  //点在圆内
    if(sgn(dst - C.r) ==0) return 1;   //圆上
    return 2;   //圆外
}

//直线和圆的关系：0 直线在圆内, 1 直线和圆相切, 2 直线在圆外
int Line_circle_relation(Line v,Circle C){
    double dst = Dis_point_line(C.c,v);
    if(sgn(dst-C.r) < 0) return 0; //直线在圆内
    if(sgn(dst-C.r) ==0) return 1;  //直线和圆相切
    return 2; //直线在圆外
}

//线段和圆的关系：0 线段在圆内, 1 线段和圆相切, 2 线段在圆外
int Seg_circle_relation(Segment v,Circle C){
    double dst = Dis_point_seg(C.c,v);
    if(sgn(dst-C.r) < 0) return 0; //线段在圆内
    if(sgn(dst-C.r) ==0) return 1;  //线段和圆相切
    return 2;    //线段在圆外
}

//直线和圆的交点   hdu 5572
int Line_cross_circle(Line v,Circle C,Point &pa,Point &pb){//pa, pb是交点。返回值是交点个数
    if(Line_circle_relation(v, C)==2) return 0;//无交点
    Point q = Point_line_proj(C.c,v);  //圆心在直线上的投影点
    double d = Dis_point_line(C.c,v);   //圆心到直线的距离
    double k = sqrt(C.r*C.r-d*d);   //
    if(sgn(k) == 0){   //1个交点，直线和圆相切
        pa = q;
        pb = q;
        return 1;
    }
    Point n=(v.p2-v.p1)/ Len(v.p2-v.p1);  //单位向量
    pa = q + n*k;
    pb = q - n*k;
    return 2;//2个交点
}
```

#### 三维几何 模板

```cpp
//-------------------三维几何----------------
//三维：点
struct Point3{
    double x,y,z;
    Point3(){}
    Point3(double x,double y,double z):x(x),y(y),z(z){}
    Point3 operator + (Point3 B){return Point3(x+B.x,y+B.y,z+B.z);}
    Point3 operator - (Point3 B){return Point3(x-B.x,y-B.y,z-B.z);}
    Point3 operator * (double k){return Point3(x*k,y*k,z*k);}
    Point3 operator / (double k){return Point3(x/k,y/k,z/k);}
    bool operator == (Point3 B){return sgn(x-B.x)==0 && sgn(y-B.y)==0 && sgn(z-B.z)==0;}
};
typedef Point3 Vector3;
//点积。和二维点积函数同名。C++允许函数同名。
double Dot(Vector3 A,Vector3 B){return A.x*B.x+A.y*B.y+A.z*B.z;}
//叉积
Vector3 Cross(Vector3 A,Vector3 B){return Point3(A.y*B.z-A.z*B.y,A.z*B.x-A.x*B.z,A.x*B.y-A.y*B.x);}
double Len(Vector3 A){return sqrt(Dot(A,A));}   //向量的长度
double Len2(Vector3 A){return Dot(A,A);}        //向量长度的平方
double Distance(Point3 A,Point3 B){
    return sqrt((A.x-B.x)*(A.x-B.x)+(A.y-B.y)*(A.y-B.y)+(A.z-B.z)*(A.z-B.z));
}
double Angle(Vector3 A,Vector3 B){return acos(Dot(A,B)/Len(A)/Len(B));}   //A与B的夹角
//三维：线
struct Line3{
    Point3 p1,p2;
    Line3(){}
    Line3(Point3 p1,Point3 p2):p1(p1),p2(p2){}
};
typedef Line3 Segment3;   //定义线段，两端点是Point p1,p2

//三角形面积的2倍
double Area2(Point3 A,Point3 B,Point3 C){return Len(Cross(B-A, C-A));}

//三维：点到直线距离
double Dis_point_line(Point3 p, Line3 v){
    return Len(Cross(v.p2-v.p1,p-v.p1))/Distance(v.p1,v.p2);
}

//三维：点在直线上
bool Point_line_relation(Point3 p,Line3 v){
    return sgn( Len(Cross(v.p1-p,v.p2-p))) == 0 && sgn(Dot(v.p1-p,v.p2-p))== 0;
}
//三维：点到线段距离。
double Dis_point_seg(Point3 p, Segment3 v){
    if(sgn(Dot(p- v.p1,v.p2-v.p1)) < 0 || sgn(Dot(p- v.p2,v.p1-v.p2)) < 0)
        return min(Distance(p,v.p1),Distance(p,v.p2));
    return Dis_point_line(p,v);
}
//三维：点 p 在直线上的投影
Point3 Point_line_proj(Point3 p, Line3 v){
    double k=Dot(v.p2-v.p1,p-v.p1)/Len2(v.p2-v.p1);
    return v.p1+(v.p2-v.p1)*k;
}
//三维：平面
struct Plane{
    Point3 p1,p2,p3;//平面上的三个点
    Plane(){}
    Plane(Point3 p1,Point3 p2,Point3 p3):p1(p1),p2(p2),p3(p3){}
};
//平面法向量
Point3 Pvec(Point3 A,Point3 B,Point3 C){ return Cross(B-A,C-A);}
Point3 Pvec(Plane f){ return Cross(f.p2-f.p1,f.p3-f.p1);}
//四点共平面
bool Point_on_plane(Point3 A,Point3 B,Point3 C,Point3 D){
    return sgn(Dot(Pvec(A,B,C),D-A)) == 0;
}
//两平面平行
int Parallel(Plane f1, Plane f2){
    return Len(Cross(Pvec(f1),Pvec(f2))) < eps;
}
//两平面垂直
int Vertical (Plane f1, Plane f2){
    return sgn(Dot(Pvec(f1),Pvec(f2)))==0;
}
//直线与平面的交点p，返回值是交点个数
int Line_cross_plane(Line3 u,Plane f,Point3 &p){
    Point3 v = Pvec(f);
    double x = Dot(v, u.p2-f.p1);
    double y = Dot(v, u.p1-f.p1);
    double d = x-y;
    if(sgn(x) == 0 && sgn(y) == 0) return -1;//-1：v在f上
    if(sgn(d) == 0)return 0;                  //0：v与f平行
    p = ((u.p1 * x)-(u.p2 * y))/d;             //v与f相交
    return 1;
}

//四面体有向体积*6
double volume4(Point3 A,Point3 B,Point3 C,Point3 D){return Dot(Cross(B-A,C-A),D-A);}
```

#### 使用示例

```cpp
int main(){
    Point a(0,1),b(0,0),c(1,1),d(1,2),p(1.5,1);
    double a1=5,b1=6,c1=1;
    Line k(a,b),k2(c,d);
    Point pr(1,1),cr(1,1); double r=1; Circle C(cr,r);

    cout<<endl<<"Line_circle_relation="<<Line_circle_relation(k,C);
    cout<<endl<<"Seg_circle_relation="<<Seg_circle_relation(k,C);
    cout<<endl<<"Point_circle_relation="<<Point_circle_relation(pr,C);
    cout<<endl<<"parallel="<<Parallel(a,b)<<endl;
    cout<<"dot="<<Dot(a,b)<<endl<<" angle="<<Angle(a,b)<<endl;
    cout<<"90:"<<sgn(Rotate(a, -pi/2).x)<<endl<<Rotate(a, -pi/2).y;
    cout<<endl<<"line angle="<<Line_angle(k)*4;
    cout<<endl<<"line place="<<Point_line_relation(p,k);
    cout<<endl<<"point_on_seg="<<Point_on_seg(p,k);
    cout<<endl<<"dis_point_line="<<Dis_point_line(p,k);
    cout<<endl<<"dis_point_line="<<Dis_point_seg(p,k);
    Point pp=Cross_point(a,b,c,d);
    cout<<endl<<"crosspoint="<<pp.x<<"  "<<pp.y;
    cout<<endl<<"cross seg="<<Cross_segment(a,b,c,d);
    cout<<endl<<"distance="<<Distance(a,b);
    cout<<endl<<"line_relation="<<Line_relation(k,k2);
    Point g[4];
    g[0]=a;g[1]=b;g[2]=c;g[3]=d;
    cout<<endl<<"Point_in_polygon="<<Point_in_polygon(p,g,4);
    cout<<endl<<"Polygon_area="<<Polygon_area(g,4);
    cout<<endl<<endl;
    return 0;
}
```
